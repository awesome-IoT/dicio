   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 354               	.global	rx_msg_task
 356               	rx_msg_task:
 357               		.stabd	46,0,0
   1:main.c        **** /*
   2:main.c        ****  * 18-748 Wireless Sensor Networks
   3:main.c        ****  * Spring 2016
   4:main.c        ****  * Lab 3: Multi-Hop Communication
   5:main.c        ****  * main.c (gateway)
   6:main.c        ****  * Kedar Amladi // kamladi. Daniel Santoro // ddsantor. Adam Selevan // aselevan.
   7:main.c        ****  */
   8:main.c        **** 
   9:main.c        **** // INCLUDES
  10:main.c        **** // standard nrk 
  11:main.c        **** #include <nrk.h>
  12:main.c        **** #include <nrk_events.h>
  13:main.c        **** #include <include.h>
  14:main.c        **** #include <ulib.h>
  15:main.c        **** #include <stdio.h>
  16:main.c        **** #include <stdlib.h>
  17:main.c        **** #include <avr/sleep.h>
  18:main.c        **** #include <hal.h>
  19:main.c        **** #include <bmac.h>
  20:main.c        **** #include <nrk_error.h>
  21:main.c        **** // this package
  22:main.c        **** #include <assembler.h>
  23:main.c        **** #include <light_pool.h>
  24:main.c        **** #include <neighbors.h>
  25:main.c        **** #include <packet_queue.h>
  26:main.c        **** #include <parser.h>
  27:main.c        **** #include <sequence_pool.h>
  28:main.c        **** #include <type_defs.h>
  29:main.c        **** 
  30:main.c        **** // DEFINES
  31:main.c        **** #define MAC_ADDR 2
  32:main.c        **** 
  33:main.c        **** // FUNCTION DECLARATIONS
  34:main.c        **** uint8_t get_server_input(void);
  35:main.c        **** void clear_serv_buf();
  36:main.c        **** void rx_msg_task(void);
  37:main.c        **** void tx_cmd_task(void);
  38:main.c        **** void tx_data_task(void);
  39:main.c        **** void tx_serv_task(void);
  40:main.c        **** void nrk_create_taskset ();
  41:main.c        **** 
  42:main.c        **** // STATE ENUM
  43:main.c        **** typedef enum {
  44:main.c        ****   STATE_ON,
  45:main.c        ****   STATE_OFF, 
  46:main.c        **** } act_state;
  47:main.c        **** 
  48:main.c        **** // TASKS
  49:main.c        **** nrk_task_type RX_MSG_TASK;
  50:main.c        **** nrk_task_type TX_CMD_TASK;
  51:main.c        **** nrk_task_type TX_DATA_TASK;
  52:main.c        **** nrk_task_type SAMPLE_TASK;
  53:main.c        **** nrk_task_type ACTUATE_TASK;
  54:main.c        **** 
  55:main.c        **** // TASK STACKS
  56:main.c        **** NRK_STK rx_msg_task_stack[NRK_APP_STACKSIZE];
  57:main.c        **** NRK_STK tx_cmd_task_stack[NRK_APP_STACKSIZE];
  58:main.c        **** NRK_STK tx_data_task_stack[NRK_APP_STACKSIZE];
  59:main.c        **** NRK_STK sample_task_stack[NRK_APP_STACKSIZE];
  60:main.c        **** NRK_STK actuate_task_stack[NRK_APP_STACKSIZE];
  61:main.c        **** 
  62:main.c        **** // CURRENT STATE
  63:main.c        **** act_state curr_state = STATE_OFF;
  64:main.c        **** 
  65:main.c        **** // BUFFERS
  66:main.c        **** uint8_t net_rx_buf[RF_MAX_PAYLOAD_SIZE];
  67:main.c        **** uint8_t net_tx_buf[RF_MAX_PAYLOAD_SIZE];
  68:main.c        **** uint8_t net_tx_index = 0;
  69:main.c        **** nrk_sem_t* net_tx_buf_mux;
  70:main.c        **** 
  71:main.c        **** // QUEUES / MUTEXES
  72:main.c        **** packet_queue act_queue;
  73:main.c        **** nrk_sem_t* act_queue_mux;
  74:main.c        **** uint16_t last_command = 0;
  75:main.c        **** 
  76:main.c        **** packet_queue cmd_tx_queue;
  77:main.c        **** nrk_sem_t* cmd_tx_queue_mux;
  78:main.c        **** 
  79:main.c        **** packet_queue data_tx_queue;
  80:main.c        **** nrk_sem_t* data_tx_queue_mux;
  81:main.c        **** 
  82:main.c        **** packet_queue hand_rx_queue;
  83:main.c        **** nrk_sem_t* hand_rx_queue_mux;
  84:main.c        **** 
  85:main.c        **** // SENSOR VALUES
  86:main.c        **** uint8_t pwr_period;
  87:main.c        **** uint8_t temp_period;
  88:main.c        **** uint8_t light_period;
  89:main.c        **** sensor_packet sensor_pkt;
  90:main.c        **** 
  91:main.c        **** // DRIVERS 
  92:main.c        **** void nrk_register_drivers();
  93:main.c        **** 
  94:main.c        **** // SEQUENCE POOLS/NUMBER
  95:main.c        **** sequence_pool_t seq_pool;
  96:main.c        **** uint16_t seq_num = 0;
  97:main.c        **** nrk_sem_t* seq_num_mux;
  98:main.c        **** 
  99:main.c        **** // GLOBAL FLAG
 100:main.c        **** uint8_t print_incoming;
 101:main.c        **** uint8_t blink_leds;
 102:main.c        **** 
 103:main.c        **** int main () {
 104:main.c        ****   // setup ports/uart
 105:main.c        ****   nrk_setup_ports ();
 106:main.c        ****   nrk_setup_uart (UART_BAUDRATE_115K2);
 107:main.c        ****   nrk_init ();
 108:main.c        **** 
 109:main.c        ****   // clear all LEDs
 110:main.c        ****   nrk_led_clr(0);
 111:main.c        ****   nrk_led_clr(1);
 112:main.c        ****   nrk_led_clr(2);
 113:main.c        ****   nrk_led_clr(3);
 114:main.c        ****     
 115:main.c        ****   // print flag
 116:main.c        ****   print_incoming = 1;
 117:main.c        ****   blink_leds = 1;
 118:main.c        **** 
 119:main.c        ****   // mutexs
 120:main.c        ****   net_tx_buf_mux    = nrk_sem_create(1, 6);
 121:main.c        ****   act_queue_mux     = nrk_sem_create(1, 6);
 122:main.c        ****   cmd_tx_queue_mux  = nrk_sem_create(1, 6);
 123:main.c        ****   data_tx_queue_mux = nrk_sem_create(1, 6);
 124:main.c        ****   hand_rx_queue_mux = nrk_sem_create(1, 6);
 125:main.c        ****   seq_num_mux       = nrk_sem_create(1, 6);
 126:main.c        **** 
 127:main.c        ****   // sensor periods (in seconds)
 128:main.c        ****   pwr_period = 30;
 129:main.c        ****   temp_period = 35;
 130:main.c        ****   light_period = 40;
 131:main.c        **** 
 132:main.c        ****   // packet queues
 133:main.c        ****   packet_queue_init(&act_queue);
 134:main.c        ****   packet_queue_init(&cmd_tx_queue);
 135:main.c        ****   packet_queue_init(&data_tx_queue);
 136:main.c        ****   packet_queue_init(&hand_rx_queue);
 137:main.c        **** 
 138:main.c        ****   // start running
 139:main.c        ****   nrk_time_set(0, 0);
 140:main.c        ****   bmac_task_config();
 141:main.c        ****   nrk_create_taskset();
 142:main.c        ****   bmac_init(13);
 143:main.c        ****   nrk_start();
 144:main.c        ****   return 0;
 145:main.c        **** }
 146:main.c        **** 
 147:main.c        **** void clear_tx_buf(){
 148:main.c        ****   for(uint8_t i = 0; i < net_tx_index; i++)
 149:main.c        ****   {
 150:main.c        ****     net_tx_buf[i] = 0;
 151:main.c        ****   }
 152:main.c        ****   net_tx_index = 0;
 153:main.c        **** }
 154:main.c        **** 
 155:main.c        **** /**
 156:main.c        ****  * rx_msg_task() - 
 157:main.c        ****  *  receive messages from the network
 158:main.c        ****  */
 159:main.c        **** void rx_msg_task() {
 359               	.LM0:
 360               	.LFBB1:
 361 0000 CF93      		push r28
 362 0002 DF93      		push r29
 363 0004 CDB7      		in r28,__SP_L__
 364 0006 DEB7      		in r29,__SP_H__
 365 0008 6397      		sbiw r28,19
 366 000a 0FB6      		in __tmp_reg__,__SREG__
 367 000c F894      		cli
 368 000e DEBF      		out __SP_H__,r29
 369 0010 0FBE      		out __SREG__,__tmp_reg__
 370 0012 CDBF      		out __SP_L__,r28
 371               	/* prologue: function */
 372               	/* frame size = 19 */
 373               	/* stack size = 21 */
 374               	.L__stack_usage = 21
 160:main.c        ****   // local variable instantiation
 161:main.c        ****   uint8_t LED_FLAG = 0;
 162:main.c        ****   packet rx_packet;
 163:main.c        ****   uint8_t len, rssi;
 164:main.c        ****   uint8_t *local_buf;
 165:main.c        ****   int8_t in_seq_pool;
 166:main.c        ****   uint16_t local_seq_num;
 167:main.c        ****   uint8_t new_node = NONE;
 168:main.c        **** 
 169:main.c        ****   // initialize network receive buffer
 170:main.c        ****   bmac_rx_pkt_set_buffer(net_rx_buf, RF_MAX_PAYLOAD_SIZE);
 376               	.LM1:
 377 0014 64E7      		ldi r22,lo8(116)
 378 0016 80E0      		ldi r24,lo8(net_rx_buf)
 379 0018 90E0      		ldi r25,hi8(net_rx_buf)
 380 001a 0E94 0000 		call bmac_rx_pkt_set_buffer
 381               	.L2:
 171:main.c        ****   
 172:main.c        ****   // Wait until bmac has started. This should be called by all tasks using bmac that do not call bm
 173:main.c        ****   while (!bmac_started ()) {
 383               	.LM2:
 384 001e 0E94 0000 		call bmac_started
 385 0022 8111      		cpse r24,__zero_reg__
 386 0024 00C0      		rjmp .L25
 174:main.c        ****     nrk_wait_until_next_period ();
 388               	.LM3:
 389 0026 0E94 0000 		call nrk_wait_until_next_period
 390 002a 00C0      		rjmp .L2
 391               	.L25:
 392 002c 10E0      		ldi r17,0
 393               	.L18:
 175:main.c        ****   }
 176:main.c        ****   
 177:main.c        ****   // loop forever
 178:main.c        ****   while(1) {
 179:main.c        ****     // LED blinking - for debug
 180:main.c        ****     if(blink_leds == BLINKLEDS) {
 395               	.LM4:
 396 002e 8091 0000 		lds r24,blink_leds
 397 0032 8130      		cpi r24,lo8(1)
 398 0034 01F4      		brne .L4
 181:main.c        ****       LED_FLAG++;
 400               	.LM5:
 401 0036 810F      		add r24,r17
 182:main.c        ****       LED_FLAG%=2;
 183:main.c        ****       if(LED_FLAG == 0) {
 403               	.LM6:
 404 0038 182F      		mov r17,r24
 405 003a 1170      		andi r17,lo8(1)
 406 003c 80FD      		sbrc r24,0
 407 003e 00C0      		rjmp .L5
 184:main.c        ****         nrk_led_set(0);
 409               	.LM7:
 410 0040 80E0      		ldi r24,0
 411 0042 90E0      		ldi r25,0
 412 0044 0E94 0000 		call nrk_led_set
 413 0048 00C0      		rjmp .L4
 414               	.L5:
 185:main.c        ****       } else {
 186:main.c        ****         nrk_led_clr(0);
 416               	.LM8:
 417 004a 80E0      		ldi r24,0
 418 004c 90E0      		ldi r25,0
 419 004e 0E94 0000 		call nrk_led_clr
 420 0052 11E0      		ldi r17,lo8(1)
 421               	.L4:
 187:main.c        ****       }      
 188:main.c        ****     }
 189:main.c        **** 
 190:main.c        ****     // only execute if there is a packet available
 191:main.c        ****     if(bmac_rx_pkt_ready()) {
 423               	.LM9:
 424 0054 0E94 0000 		call bmac_rx_pkt_ready
 425 0058 8823      		tst r24
 426 005a 01F4      		brne .+2
 427 005c 00C0      		rjmp .L7
 192:main.c        ****       // get the packet, parse and release
 193:main.c        ****       parse_msg(&rx_packet, &net_rx_buf, len);
 429               	.LM10:
 430 005e 4B89      		ldd r20,Y+19
 431 0060 60E0      		ldi r22,lo8(net_rx_buf)
 432 0062 70E0      		ldi r23,hi8(net_rx_buf)
 433 0064 CE01      		movw r24,r28
 434 0066 0196      		adiw r24,1
 435 0068 0E94 0000 		call parse_msg
 194:main.c        ****       local_buf = bmac_rx_pkt_get(&len, &rssi);
 437               	.LM11:
 438 006c BE01      		movw r22,r28
 439 006e 6E5E      		subi r22,-18
 440 0070 7F4F      		sbci r23,-1
 441 0072 CE01      		movw r24,r28
 442 0074 4396      		adiw r24,19
 443 0076 0E94 0000 		call bmac_rx_pkt_get
 195:main.c        ****       bmac_rx_pkt_release ();  
 445               	.LM12:
 446 007a 0E94 0000 		call bmac_rx_pkt_release
 196:main.c        ****       
 197:main.c        ****       // print incoming packet if appropriate
 198:main.c        ****       if(print_incoming == 1) {
 448               	.LM13:
 449 007e 8091 0000 		lds r24,print_incoming
 450 0082 8130      		cpi r24,lo8(1)
 451 0084 01F4      		brne .L8
 199:main.c        ****         nrk_kprintf (PSTR ("rx pkt:\r\n"));
 453               	.LM14:
 454 0086 80E0      		ldi r24,lo8(__c.3830)
 455 0088 90E0      		ldi r25,hi8(__c.3830)
 456 008a 0E94 0000 		call nrk_kprintf
 200:main.c        ****         print_packet(&rx_packet);     
 458               	.LM15:
 459 008e CE01      		movw r24,r28
 460 0090 0196      		adiw r24,1
 461 0092 0E94 0000 		call print_packet
 462               	.L8:
 201:main.c        ****       }
 202:main.c        ****       
 203:main.c        ****       // only receive the message if it's not from the gateway
 204:main.c        ****       //  NOTE: this is required because the gateway will hear re-transmitted packets 
 205:main.c        ****       //    originally from itself.
 206:main.c        ****       if(rx_packet.source_id != MAC_ADDR) {
 464               	.LM16:
 465 0096 6981      		ldd r22,Y+1
 466 0098 6230      		cpi r22,lo8(2)
 467 009a 01F4      		brne .+2
 468 009c 00C0      		rjmp .L7
 207:main.c        **** 
 208:main.c        ****         // check to see if this node is in the sequence pool, if not then add it
 209:main.c        ****         in_seq_pool = in_sequence_pool(&seq_pool, rx_packet.source_id);
 470               	.LM17:
 471 009e 80E0      		ldi r24,lo8(seq_pool)
 472 00a0 90E0      		ldi r25,hi8(seq_pool)
 473 00a2 0E94 0000 		call in_sequence_pool
 210:main.c        ****         if(in_seq_pool == -1) {
 475               	.LM18:
 476 00a6 8F3F      		cpi r24,lo8(-1)
 477 00a8 01F4      		brne .L19
 211:main.c        ****           add_to_sequence_pool(&seq_pool, rx_packet.source_id, rx_packet.seq_num);
 479               	.LM19:
 480 00aa 4B81      		ldd r20,Y+3
 481 00ac 5C81      		ldd r21,Y+4
 482 00ae 6981      		ldd r22,Y+1
 483 00b0 80E0      		ldi r24,lo8(seq_pool)
 484 00b2 90E0      		ldi r25,hi8(seq_pool)
 485 00b4 0E94 0000 		call add_to_sequence_pool
 212:main.c        ****           new_node = NODE_FOUND;
 487               	.LM20:
 488 00b8 01E0      		ldi r16,lo8(1)
 489 00ba 00C0      		rjmp .L10
 490               	.L19:
 491 00bc 00E0      		ldi r16,0
 492               	.L10:
 213:main.c        ****         }
 214:main.c        ****       
 215:main.c        ****         // determine if we should act on this packet based on the sequence number
 216:main.c        ****         local_seq_num = get_sequence_number(&seq_pool, rx_packet.source_id);
 494               	.LM21:
 495 00be 6981      		ldd r22,Y+1
 496 00c0 80E0      		ldi r24,lo8(seq_pool)
 497 00c2 90E0      		ldi r25,hi8(seq_pool)
 498 00c4 0E94 0000 		call get_sequence_number
 217:main.c        ****         if((rx_packet.seq_num > local_seq_num) || (new_node == NODE_FOUND)) {
 500               	.LM22:
 501 00c8 4B81      		ldd r20,Y+3
 502 00ca 5C81      		ldd r21,Y+4
 503 00cc 8417      		cp r24,r20
 504 00ce 9507      		cpc r25,r21
 505 00d0 00F0      		brlo .L11
 507               	.LM23:
 508 00d2 0130      		cpi r16,lo8(1)
 509 00d4 01F0      		breq .+2
 510 00d6 00C0      		rjmp .L7
 511               	.L11:
 218:main.c        ****           
 219:main.c        ****           // update the sequence pool and reset the new_node flag
 220:main.c        ****           update_sequence_pool(&seq_pool, rx_packet.source_id, rx_packet.seq_num);
 513               	.LM24:
 514 00d8 6981      		ldd r22,Y+1
 515 00da 80E0      		ldi r24,lo8(seq_pool)
 516 00dc 90E0      		ldi r25,hi8(seq_pool)
 517 00de 0E94 0000 		call update_sequence_pool
 221:main.c        ****           new_node = NONE;
 222:main.c        ****           
 223:main.c        ****           // put the message in the right queue based on the type
 224:main.c        ****           switch(rx_packet.type) {
 519               	.LM25:
 520 00e2 8A81      		ldd r24,Y+2
 521 00e4 8630      		cpi r24,lo8(6)
 522 00e6 01F0      		breq .L12
 523 00e8 00F4      		brsh .L13
 524 00ea 8530      		cpi r24,lo8(5)
 525 00ec 01F0      		breq .+2
 526 00ee 00C0      		rjmp .L7
 225:main.c        ****             case MSG_CMD:
 226:main.c        ****             {
 227:main.c        ****               /*
 228:main.c        ****               command received -- either act or forward
 229:main.c        ****               Payload format: [NN][D][A]
 230:main.c        ****               NN: Command ID
 231:main.c        ****               D: Destination Address
 232:main.c        ****               A: Action!!!
 233:main.c        ****               
 234:main.c        ****               if command is for this node and hasn't been received yet, add it
 235:main.c        ****               to the action queue. Otherwise, add it to the cmd_tx queue for 
 236:main.c        ****               forwarding to other nodes.
 237:main.c        ****                 */
 238:main.c        ****               if((last_command < (uint16_t)rx_packet.payload[CMD_ID_INDEX]) &&
 239:main.c        ****                   (rx_packet.payload[CMD_NODE_ID_INDEX] == MAC_ADDR)) 
 240:main.c        ****               {
 241:main.c        ****                 nrk_kprintf (PSTR ("packet for me!\r\n"));
 242:main.c        ****                 last_command = (uint16_t)rx_packet.payload[CMD_ID_INDEX]; // need to cast again her
 243:main.c        ****                 nrk_sem_pend(act_queue_mux);
 244:main.c        ****                 push(&act_queue, &rx_packet);
 245:main.c        ****                 nrk_sem_post(act_queue_mux);
 246:main.c        ****               } 
 247:main.c        ****               else 
 248:main.c        ****               {
 249:main.c        ****                 nrk_sem_pend(cmd_tx_queue_mux);
 250:main.c        ****                 push(&cmd_tx_queue, &rx_packet);
 251:main.c        ****                 nrk_sem_post(cmd_tx_queue_mux);
 252:main.c        ****               }
 253:main.c        ****               break;
 254:main.c        ****             }
 255:main.c        ****             // command act received -- forward to the server
 256:main.c        ****             case MSG_CMDACK:
 257:main.c        ****               nrk_sem_pend(cmd_tx_queue_mux);
 258:main.c        ****               push(&cmd_tx_queue, &rx_packet);
 259:main.c        ****               nrk_sem_post(cmd_tx_queue_mux);
 260:main.c        ****               break;
 261:main.c        ****             // data received or command ack received -> forward to server
 262:main.c        ****             case MSG_DATA:
 263:main.c        ****               nrk_sem_pend(data_tx_queue_mux);
 528               	.LM26:
 529 00f0 8091 0000 		lds r24,data_tx_queue_mux
 530 00f4 9091 0000 		lds r25,data_tx_queue_mux+1
 531 00f8 0E94 0000 		call nrk_sem_pend
 264:main.c        ****               push(&data_tx_queue, &rx_packet);
 533               	.LM27:
 534 00fc BE01      		movw r22,r28
 535 00fe 6F5F      		subi r22,-1
 536 0100 7F4F      		sbci r23,-1
 537 0102 80E0      		ldi r24,lo8(data_tx_queue)
 538 0104 90E0      		ldi r25,hi8(data_tx_queue)
 539 0106 0E94 0000 		call push
 265:main.c        ****               nrk_sem_post(data_tx_queue_mux);
 541               	.LM28:
 542 010a 8091 0000 		lds r24,data_tx_queue_mux
 543 010e 9091 0000 		lds r25,data_tx_queue_mux+1
 544 0112 00C0      		rjmp .L23
 545               	.L13:
 224:main.c        ****             case MSG_CMD:
 547               	.LM29:
 548 0114 8730      		cpi r24,lo8(7)
 549 0116 01F0      		breq .L15
 550 0118 8830      		cpi r24,lo8(8)
 551 011a 01F0      		breq .+2
 552 011c 00C0      		rjmp .L7
 266:main.c        ****               break;
 267:main.c        ****             // handshake message recieved -> deal with in handshake function
 268:main.c        ****             case MSG_HAND:
 269:main.c        ****               nrk_sem_pend(hand_rx_queue_mux);
 554               	.LM30:
 555 011e 8091 0000 		lds r24,hand_rx_queue_mux
 556 0122 9091 0000 		lds r25,hand_rx_queue_mux+1
 557 0126 0E94 0000 		call nrk_sem_pend
 270:main.c        ****               push(&hand_rx_queue, &rx_packet);
 559               	.LM31:
 560 012a BE01      		movw r22,r28
 561 012c 6F5F      		subi r22,-1
 562 012e 7F4F      		sbci r23,-1
 563 0130 80E0      		ldi r24,lo8(hand_rx_queue)
 564 0132 90E0      		ldi r25,hi8(hand_rx_queue)
 565 0134 0E94 0000 		call push
 271:main.c        ****               nrk_sem_post(hand_rx_queue_mux);
 567               	.LM32:
 568 0138 8091 0000 		lds r24,hand_rx_queue_mux
 569 013c 9091 0000 		lds r25,hand_rx_queue_mux+1
 570 0140 00C0      		rjmp .L23
 571               	.L12:
 238:main.c        ****                   (rx_packet.payload[CMD_NODE_ID_INDEX] == MAC_ADDR)) 
 573               	.LM33:
 574 0142 8A85      		ldd r24,Y+10
 575 0144 90E0      		ldi r25,0
 576 0146 2091 0000 		lds r18,last_command
 577 014a 3091 0000 		lds r19,last_command+1
 578 014e 2817      		cp r18,r24
 579 0150 3907      		cpc r19,r25
 580 0152 00F4      		brsh .L15
 238:main.c        ****                   (rx_packet.payload[CMD_NODE_ID_INDEX] == MAC_ADDR)) 
 582               	.LM34:
 583 0154 8C85      		ldd r24,Y+12
 584 0156 8230      		cpi r24,lo8(2)
 585 0158 01F4      		brne .L15
 241:main.c        ****                 last_command = (uint16_t)rx_packet.payload[CMD_ID_INDEX]; // need to cast again her
 587               	.LM35:
 588 015a 80E0      		ldi r24,lo8(__c.3833)
 589 015c 90E0      		ldi r25,hi8(__c.3833)
 590 015e 0E94 0000 		call nrk_kprintf
 242:main.c        ****                 nrk_sem_pend(act_queue_mux);
 592               	.LM36:
 593 0162 8A85      		ldd r24,Y+10
 594 0164 90E0      		ldi r25,0
 595 0166 9093 0000 		sts last_command+1,r25
 596 016a 8093 0000 		sts last_command,r24
 243:main.c        ****                 push(&act_queue, &rx_packet);
 598               	.LM37:
 599 016e 8091 0000 		lds r24,act_queue_mux
 600 0172 9091 0000 		lds r25,act_queue_mux+1
 601 0176 0E94 0000 		call nrk_sem_pend
 244:main.c        ****                 nrk_sem_post(act_queue_mux);
 603               	.LM38:
 604 017a BE01      		movw r22,r28
 605 017c 6F5F      		subi r22,-1
 606 017e 7F4F      		sbci r23,-1
 607 0180 80E0      		ldi r24,lo8(act_queue)
 608 0182 90E0      		ldi r25,hi8(act_queue)
 609 0184 0E94 0000 		call push
 245:main.c        ****               } 
 611               	.LM39:
 612 0188 8091 0000 		lds r24,act_queue_mux
 613 018c 9091 0000 		lds r25,act_queue_mux+1
 614 0190 00C0      		rjmp .L23
 615               	.L15:
 257:main.c        ****               push(&cmd_tx_queue, &rx_packet);
 617               	.LM40:
 618 0192 8091 0000 		lds r24,cmd_tx_queue_mux
 619 0196 9091 0000 		lds r25,cmd_tx_queue_mux+1
 620 019a 0E94 0000 		call nrk_sem_pend
 258:main.c        ****               nrk_sem_post(cmd_tx_queue_mux);
 622               	.LM41:
 623 019e BE01      		movw r22,r28
 624 01a0 6F5F      		subi r22,-1
 625 01a2 7F4F      		sbci r23,-1
 626 01a4 80E0      		ldi r24,lo8(cmd_tx_queue)
 627 01a6 90E0      		ldi r25,hi8(cmd_tx_queue)
 628 01a8 0E94 0000 		call push
 259:main.c        ****               break;
 630               	.LM42:
 631 01ac 8091 0000 		lds r24,cmd_tx_queue_mux
 632 01b0 9091 0000 		lds r25,cmd_tx_queue_mux+1
 633               	.L23:
 635               	.LM43:
 636 01b4 0E94 0000 		call nrk_sem_post
 637               	.L7:
 272:main.c        ****               break;
 273:main.c        ****             // gateway message -> for future expansion
 274:main.c        ****             case MSG_GATEWAY:
 275:main.c        ****               // do nothing...no messages have been defined with this type yet
 276:main.c        ****               break;
 277:main.c        ****             // no message
 278:main.c        ****             case MSG_NO_MESSAGE:
 279:main.c        ****               // do nothing. 
 280:main.c        ****               // NOTE: this is a valid case. If the message is not 'parsible' then it can be
 281:main.c        ****               //  given a 'NO_MESSAGE' type.
 282:main.c        ****               break;
 283:main.c        ****             default:
 284:main.c        ****               // do nothing
 285:main.c        ****               // NOTICE: really this should never happen. Eventually, throw and error here.
 286:main.c        ****               break;
 287:main.c        ****           }
 288:main.c        ****         }        
 289:main.c        ****       }
 290:main.c        ****     }
 291:main.c        ****     nrk_wait_until_next_period();
 639               	.LM44:
 640 01b8 0E94 0000 		call nrk_wait_until_next_period
 292:main.c        ****   }
 642               	.LM45:
 643 01bc 00C0      		rjmp .L18
 651               	.Lscope1:
 653               		.stabd	78,0,0
 655               	.global	sample_task
 657               	sample_task:
 658               		.stabd	46,0,0
 293:main.c        **** }
 294:main.c        **** 
 295:main.c        **** /**
 296:main.c        ****  * tx_cmd_task() -
 297:main.c        ****  *  send all commands out to the network.
 298:main.c        ****  */
 299:main.c        **** void tx_cmd_task() {
 300:main.c        ****   // local variable instantiation
 301:main.c        ****   uint8_t LED_FLAG = 0;
 302:main.c        ****   uint16_t val;
 303:main.c        ****   nrk_sig_t tx_done_signal;
 304:main.c        ****   nrk_sig_mask_t ret;
 305:main.c        ****   packet tx_packet;
 306:main.c        ****   uint8_t tx_cmd_queue_size;
 307:main.c        **** 
 308:main.c        ****   // Wait until bmac has started. This should be called by all tasks 
 309:main.c        ****   //  using bmac that do not call bmac_init().
 310:main.c        ****   while(!bmac_started()) {
 311:main.c        ****     nrk_wait_until_next_period();
 312:main.c        ****   }
 313:main.c        **** 
 314:main.c        ****   // Get and register the tx_done_signal to perform non-blocking transmits
 315:main.c        ****   tx_done_signal = bmac_get_tx_done_signal();
 316:main.c        ****   nrk_signal_register(tx_done_signal);
 317:main.c        **** 
 318:main.c        ****   // loop forever
 319:main.c        ****   while(1){
 320:main.c        ****     // LED blinking - for debug
 321:main.c        ****     if(blink_leds == BLINKLEDS) {
 322:main.c        ****       LED_FLAG++;
 323:main.c        ****       LED_FLAG%=2;
 324:main.c        ****       /*
 325:main.c        ****       if(LED_FLAG == 0) {
 326:main.c        ****         nrk_led_set(1);
 327:main.c        ****       } else {
 328:main.c        ****         nrk_led_clr(1);
 329:main.c        ****       }  */    
 330:main.c        ****     }
 331:main.c        **** 
 332:main.c        ****     // atomically get the queue size
 333:main.c        ****     nrk_sem_pend(cmd_tx_queue_mux);
 334:main.c        ****       tx_cmd_queue_size = cmd_tx_queue.size;
 335:main.c        ****     nrk_sem_post(cmd_tx_queue_mux);
 336:main.c        **** 
 337:main.c        ****     /**
 338:main.c        ****      * loop on queue size received above, and no more.
 339:main.c        ****      *  NOTE: during this loop the queue can be added to. If, for instance,
 340:main.c        ****      *    a "while(cmd_tx_queue.size > 0)" was used a few bad things could happen
 341:main.c        ****      *      (1) a mutex would be required around the entire loop - BAD IDEA
 342:main.c        ****      *      (2) the queue could be added to while this loop is running, thus
 343:main.c        ****      *        making the loop unbounded - BAD IDEA
 344:main.c        ****      *      (3) the size the queue read and the actual size of the queue could be 
 345:main.c        ****      *        incorrect due to preemtion - BAD IDEA
 346:main.c        ****      *    Doing it this way bounds this loop to the maximum size of the queue
 347:main.c        ****      *    at any given time, regardless of whether or not the queue has been 
 348:main.c        ****      *    added to by another task.
 349:main.c        ****      */
 350:main.c        ****     for(uint8_t i = 0; i < tx_cmd_queue_size; i++) {
 351:main.c        ****       // get a packet out of the queue.
 352:main.c        ****       nrk_sem_pend(cmd_tx_queue_mux);
 353:main.c        ****       pop(&cmd_tx_queue, &tx_packet);
 354:main.c        ****       nrk_sem_post(cmd_tx_queue_mux);
 355:main.c        **** 
 356:main.c        ****       // NOTE: a mutex is required around the network transmit buffer because 
 357:main.c        ****       //  tx_cmd_task() also uses it.
 358:main.c        ****       nrk_sem_pend(net_tx_buf_mux);
 359:main.c        ****       net_tx_index = assemble_packet(&net_tx_buf, &tx_packet);
 360:main.c        **** 
 361:main.c        ****       // send the packet
 362:main.c        ****       val = bmac_tx_pkt_nonblocking(net_tx_buf, net_tx_index);
 363:main.c        ****       ret = nrk_event_wait (SIG(tx_done_signal));
 364:main.c        **** 
 365:main.c        ****       printf("tx pkt: %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n",
 366:main.c        ****         net_tx_buf[0],net_tx_buf[1],net_tx_buf[2],net_tx_buf[3],net_tx_buf[4],
 367:main.c        ****         net_tx_buf[5],net_tx_buf[6],net_tx_buf[7],net_tx_buf[8],net_tx_buf[9]);
 368:main.c        ****       
 369:main.c        ****       // Just check to be sure signal is okay
 370:main.c        ****       if(ret & (SIG(tx_done_signal) == 0)) {
 371:main.c        ****         nrk_kprintf (PSTR ("TX done signal error\r\n"));
 372:main.c        ****       }
 373:main.c        ****       clear_tx_buf();
 374:main.c        ****       nrk_sem_post(net_tx_buf_mux);     
 375:main.c        ****     }
 376:main.c        ****     nrk_wait_until_next_period();
 377:main.c        ****   }
 378:main.c        **** }
 379:main.c        **** 
 380:main.c        **** /**
 381:main.c        ****  * tx_data_task() -
 382:main.c        ****  *  send standard messages out to the network (i.e. handshake messages, etc.)
 383:main.c        ****  */
 384:main.c        **** void tx_data_task() {
 385:main.c        ****   // local variable initialization
 386:main.c        ****   uint8_t LED_FLAG = 0;
 387:main.c        ****   uint16_t val;
 388:main.c        ****   nrk_sig_t tx_done_signal;
 389:main.c        ****   nrk_sig_mask_t ret;
 390:main.c        ****   packet tx_packet;
 391:main.c        ****   uint8_t tx_data_queue_size;
 392:main.c        **** 
 393:main.c        ****   // Wait until bmac has started. This should be called by all tasks 
 394:main.c        ****   //  using bmac that do not call bmac_init().
 395:main.c        ****   while(!bmac_started ()) {
 396:main.c        ****     nrk_wait_until_next_period ();
 397:main.c        ****   }
 398:main.c        **** 
 399:main.c        ****   // Get and register the tx_done_signal to perform non-blocking transmits
 400:main.c        ****   tx_done_signal = bmac_get_tx_done_signal();
 401:main.c        ****   nrk_signal_register(tx_done_signal);
 402:main.c        ****   
 403:main.c        ****   while(1) {
 404:main.c        ****     // LED blinking - for debug
 405:main.c        ****     if(blink_leds == BLINKLEDS) {
 406:main.c        ****       LED_FLAG++;
 407:main.c        ****       LED_FLAG%=2;
 408:main.c        ****       if(LED_FLAG == 0) {
 409:main.c        ****         nrk_led_set(3);
 410:main.c        ****       } else {
 411:main.c        ****         nrk_led_clr(3);
 412:main.c        ****       }      
 413:main.c        ****     }
 414:main.c        ****  
 415:main.c        ****     // atomically get the queue size
 416:main.c        ****     nrk_sem_pend(data_tx_queue_mux);
 417:main.c        ****       tx_data_queue_size = data_tx_queue.size;
 418:main.c        ****     nrk_sem_post(data_tx_queue_mux);
 419:main.c        **** 
 420:main.c        ****     /**
 421:main.c        ****      * loop on queue size received above, and no more.
 422:main.c        ****      *  NOTE: during this loop the queue can be added to. If, for instance,
 423:main.c        ****      *    a "while(node_tx_queue.size > 0)" was used a few bad things could happen
 424:main.c        ****      *      (1) a mutex would be required around the entire loop - BAD IDEA
 425:main.c        ****      *      (2) the queue could be added to while this loop is running, thus
 426:main.c        ****      *        making the loop unbounded - BAD IDEA
 427:main.c        ****      *      (3) the size the queue read and the actual size of the queue could be 
 428:main.c        ****      *        incorrect due to preemtion - BAD IDEA
 429:main.c        ****      *    Doing it this way bounds this loop to the maximum size of the queue
 430:main.c        ****      *    at any given time, regardless of whether or not the queue has been 
 431:main.c        ****      *    added to by another task.
 432:main.c        ****      */
 433:main.c        ****     for(uint8_t i = 0; i < tx_data_queue_size; i++) {
 434:main.c        ****       // get a packet out of the queue.
 435:main.c        ****       nrk_sem_pend(data_tx_queue_mux);
 436:main.c        ****      // printf("Q front:%d\r\n", data_tx_queue.front);// for debug
 437:main.c        ****       pop(&data_tx_queue, &tx_packet);
 438:main.c        ****       nrk_sem_post(data_tx_queue_mux);
 439:main.c        **** 
 440:main.c        ****       if(print_incoming == 1){
 441:main.c        ****         //nrk_kprintf (PSTR ("Asm pkt:\r\n"));
 442:main.c        ****         //print_packet(&tx_packet);
 443:main.c        ****       }
 444:main.c        **** 
 445:main.c        ****       // NOTE: a mutex is required around the network transmit buffer because 
 446:main.c        ****       //  tx_cmd_task() also uses it.
 447:main.c        ****       nrk_sem_pend(net_tx_buf_mux);
 448:main.c        ****       net_tx_index = assemble_packet(&net_tx_buf, &tx_packet);
 449:main.c        **** 
 450:main.c        ****       // send the packet
 451:main.c        ****       val = bmac_tx_pkt_nonblocking(net_tx_buf, net_tx_index);
 452:main.c        ****       ret = nrk_event_wait (SIG(tx_done_signal));
 453:main.c        **** 
 454:main.c        ****       /*printf("tx pkt: %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n",
 455:main.c        ****         net_tx_buf[0],net_tx_buf[1],net_tx_buf[2],net_tx_buf[3],net_tx_buf[4],
 456:main.c        ****         net_tx_buf[5],net_tx_buf[6],net_tx_buf[7],net_tx_buf[8],net_tx_buf[9]);*/
 457:main.c        **** 
 458:main.c        ****         //printf("index: %d\r\n", net_tx_index);
 459:main.c        **** 
 460:main.c        ****       // Just check to be sure signal is okay
 461:main.c        ****       if(ret & (SIG(tx_done_signal) == 0)) {
 462:main.c        ****         nrk_kprintf (PSTR ("TX done signal error\r\n"));
 463:main.c        ****       }
 464:main.c        ****       clear_tx_buf();
 465:main.c        ****       nrk_sem_post(net_tx_buf_mux);     
 466:main.c        ****     }
 467:main.c        ****     nrk_wait_until_next_period();
 468:main.c        ****   }
 469:main.c        **** }
 470:main.c        **** 
 471:main.c        **** 
 472:main.c        **** /**
 473:main.c        ****  * sample_task() -
 474:main.c        ****  *  sample any sensors that are supposed to be sampled.
 475:main.c        ****  */
 476:main.c        **** void sample_task() {
 660               	.LM46:
 661               	.LFBB2:
 662 01be CF93      		push r28
 663 01c0 DF93      		push r29
 664 01c2 CDB7      		in r28,__SP_L__
 665 01c4 DEB7      		in r29,__SP_H__
 666 01c6 6197      		sbiw r28,17
 667 01c8 0FB6      		in __tmp_reg__,__SREG__
 668 01ca F894      		cli
 669 01cc DEBF      		out __SP_H__,r29
 670 01ce 0FBE      		out __SREG__,__tmp_reg__
 671 01d0 CDBF      		out __SP_L__,r28
 672               	/* prologue: function */
 673               	/* frame size = 17 */
 674               	/* stack size = 19 */
 675               	.L__stack_usage = 19
 477:main.c        ****   // local variable instantiation
 478:main.c        ****   uint8_t LED_FLAG = 0;
 479:main.c        ****   uint8_t pwr_period_count = 0;
 480:main.c        ****   uint8_t temp_period_count = 0;
 481:main.c        ****   uint8_t light_period_count = 0;
 482:main.c        ****   uint8_t sensor_sampled = FALSE;
 483:main.c        ****   uint16_t local_pwr_val = 0;
 484:main.c        ****   uint16_t local_temp_val = 0;
 485:main.c        ****   uint16_t local_light_val = 0;
 486:main.c        ****   packet tx_packet;
 487:main.c        **** 
 488:main.c        ****   // initialize sensor packet
 489:main.c        ****   sensor_pkt.pwr_val = local_pwr_val;
 677               	.LM47:
 678 01d2 1092 0000 		sts sensor_pkt+1,__zero_reg__
 679 01d6 1092 0000 		sts sensor_pkt,__zero_reg__
 490:main.c        ****   sensor_pkt.temp_val = local_temp_val;
 681               	.LM48:
 682 01da 1092 0000 		sts sensor_pkt+2+1,__zero_reg__
 683 01de 1092 0000 		sts sensor_pkt+2,__zero_reg__
 491:main.c        ****   sensor_pkt.light_val = local_light_val;
 685               	.LM49:
 686 01e2 1092 0000 		sts sensor_pkt+4+1,__zero_reg__
 687 01e6 1092 0000 		sts sensor_pkt+4,__zero_reg__
 492:main.c        **** 
 493:main.c        ****   // initialize tx_packet
 494:main.c        ****   tx_packet.source_id = MAC_ADDR;
 689               	.LM50:
 690 01ea 82E0      		ldi r24,lo8(2)
 691 01ec 8983      		std Y+1,r24
 495:main.c        ****   tx_packet.type = MSG_DATA;
 693               	.LM51:
 694 01ee 85E0      		ldi r24,lo8(5)
 695 01f0 8A83      		std Y+2,r24
 496:main.c        ****   tx_packet.num_hops = 0;
 697               	.LM52:
 698 01f2 1D82      		std Y+5,__zero_reg__
 485:main.c        ****   packet tx_packet;
 700               	.LM53:
 701 01f4 812C      		mov r8,__zero_reg__
 702 01f6 912C      		mov r9,__zero_reg__
 484:main.c        ****   uint16_t local_light_val = 0;
 704               	.LM54:
 705 01f8 A12C      		mov r10,__zero_reg__
 706 01fa B12C      		mov r11,__zero_reg__
 483:main.c        ****   uint16_t local_temp_val = 0;
 708               	.LM55:
 709 01fc C12C      		mov r12,__zero_reg__
 710 01fe D12C      		mov r13,__zero_reg__
 481:main.c        ****   uint8_t sensor_sampled = FALSE;
 712               	.LM56:
 713 0200 00E0      		ldi r16,0
 480:main.c        ****   uint8_t light_period_count = 0;
 715               	.LM57:
 716 0202 F12C      		mov r15,__zero_reg__
 479:main.c        ****   uint8_t temp_period_count = 0;
 718               	.LM58:
 719 0204 10E0      		ldi r17,0
 478:main.c        ****   uint8_t pwr_period_count = 0;
 721               	.LM59:
 722 0206 E12C      		mov r14,__zero_reg__
 723               	.L34:
 497:main.c        **** 
 498:main.c        ****   // loop forever
 499:main.c        ****   while(1) {
 500:main.c        ****     // LED blinking - for debug
 501:main.c        ****     if(blink_leds == BLINKLEDS) {
 725               	.LM60:
 726 0208 8091 0000 		lds r24,blink_leds
 727 020c 8130      		cpi r24,lo8(1)
 728 020e 01F4      		brne .L27
 502:main.c        ****       LED_FLAG++;
 730               	.LM61:
 731 0210 8E0D      		add r24,r14
 503:main.c        ****       LED_FLAG%=2;
 504:main.c        ****       if(LED_FLAG == 0) {
 733               	.LM62:
 734 0212 982F      		mov r25,r24
 735 0214 9170      		andi r25,lo8(1)
 736 0216 E92E      		mov r14,r25
 737 0218 80FF      		sbrs r24,0
 738 021a 00C0      		rjmp .L27
 505:main.c        ****         //nrk_led_set(2);
 506:main.c        ****       } else {
 507:main.c        ****         nrk_led_clr(2);
 740               	.LM63:
 741 021c 82E0      		ldi r24,lo8(2)
 742 021e 90E0      		ldi r25,0
 743 0220 0E94 0000 		call nrk_led_clr
 744 0224 EE24      		clr r14
 745 0226 E394      		inc r14
 746               	.L27:
 508:main.c        ****       }      
 509:main.c        ****     }
 510:main.c        **** 
 511:main.c        ****     // update period counts
 512:main.c        ****     pwr_period_count++;
 748               	.LM64:
 749 0228 81E0      		ldi r24,lo8(1)
 750 022a 810F      		add r24,r17
 513:main.c        ****     temp_period_count++;
 752               	.LM65:
 753 022c F394      		inc r15
 514:main.c        ****     light_period_count++;
 755               	.LM66:
 756 022e 0F5F      		subi r16,lo8(-(1))
 515:main.c        ****     pwr_period_count %= pwr_period;
 758               	.LM67:
 759 0230 6091 0000 		lds r22,pwr_period
 760 0234 0E94 0000 		call __udivmodqi4
 761 0238 192F      		mov r17,r25
 516:main.c        ****     temp_period_count %= temp_period;
 763               	.LM68:
 764 023a 6091 0000 		lds r22,temp_period
 765 023e 8F2D      		mov r24,r15
 766 0240 0E94 0000 		call __udivmodqi4
 767 0244 392F      		mov r19,r25
 768 0246 F92E      		mov r15,r25
 517:main.c        ****     light_period_count %= light_period;
 770               	.LM69:
 771 0248 6091 0000 		lds r22,light_period
 772 024c 802F      		mov r24,r16
 773 024e 0E94 0000 		call __udivmodqi4
 774 0252 092F      		mov r16,r25
 518:main.c        **** 
 519:main.c        ****     // sample power sensor if appropriate
 520:main.c        ****     if(pwr_period_count == SAMPLE_SENSOR) {
 776               	.LM70:
 777 0254 1111      		cpse r17,__zero_reg__
 778 0256 00C0      		rjmp .L35
 521:main.c        ****       //TODO: SAMPLE POWER SENSOR
 522:main.c        ****       local_pwr_val++;
 780               	.LM71:
 781 0258 8FEF      		ldi r24,-1
 782 025a C81A      		sub r12,r24
 783 025c D80A      		sbc r13,r24
 523:main.c        ****       sensor_pkt.pwr_val = local_pwr_val;
 785               	.LM72:
 786 025e D092 0000 		sts sensor_pkt+1,r13
 787 0262 C092 0000 		sts sensor_pkt,r12
 524:main.c        ****       sensor_sampled = TRUE;
 789               	.LM73:
 790 0266 21E0      		ldi r18,lo8(1)
 791 0268 00C0      		rjmp .L28
 792               	.L35:
 793 026a 20E0      		ldi r18,0
 794               	.L28:
 525:main.c        ****       pwr_period_count = 0;
 526:main.c        ****     }
 527:main.c        **** 
 528:main.c        ****     // sample temperature sensor if appropriate
 529:main.c        ****     if(temp_period_count == SAMPLE_SENSOR) {
 796               	.LM74:
 797 026c 3111      		cpse r19,__zero_reg__
 798 026e 00C0      		rjmp .L29
 530:main.c        ****       //TODO: SAMPLE TEMP SENSOR
 531:main.c        ****       local_temp_val++;
 800               	.LM75:
 801 0270 8FEF      		ldi r24,-1
 802 0272 A81A      		sub r10,r24
 803 0274 B80A      		sbc r11,r24
 532:main.c        ****       sensor_pkt.temp_val = local_temp_val;
 805               	.LM76:
 806 0276 B092 0000 		sts sensor_pkt+2+1,r11
 807 027a A092 0000 		sts sensor_pkt+2,r10
 533:main.c        ****       sensor_sampled = TRUE;
 534:main.c        ****       temp_period_count = 0;
 535:main.c        ****     }
 536:main.c        **** 
 537:main.c        ****     // sample light sensor if appropriate
 538:main.c        ****     if(light_period_count == SAMPLE_SENSOR) {
 809               	.LM77:
 810 027e 9923      		tst r25
 811 0280 01F0      		breq .L30
 812 0282 00C0      		rjmp .L31
 813               	.L29:
 814 0284 9111      		cpse r25,__zero_reg__
 815 0286 00C0      		rjmp .L32
 816               	.L30:
 539:main.c        ****       //TODO: SAMPLE LIGHT SENSOR
 540:main.c        ****       local_light_val++;
 818               	.LM78:
 819 0288 9FEF      		ldi r25,-1
 820 028a 891A      		sub r8,r25
 821 028c 990A      		sbc r9,r25
 541:main.c        ****       sensor_pkt.light_val = local_light_val;
 823               	.LM79:
 824 028e 9092 0000 		sts sensor_pkt+4+1,r9
 825 0292 8092 0000 		sts sensor_pkt+4,r8
 542:main.c        ****       sensor_sampled = TRUE;
 543:main.c        ****       light_period_count = 0;
 827               	.LM80:
 828 0296 00E0      		ldi r16,0
 829 0298 00C0      		rjmp .L31
 830               	.L32:
 544:main.c        ****     }
 545:main.c        **** 
 546:main.c        ****     // if a sensor has been sampled, send a packet out
 547:main.c        ****     if(sensor_sampled == TRUE) {
 832               	.LM81:
 833 029a 2130      		cpi r18,lo8(1)
 834 029c 01F4      		brne .L33
 835               	.L31:
 548:main.c        ****       // update sequence number
 549:main.c        ****       nrk_sem_post(seq_num_mux);
 837               	.LM82:
 838 029e 8091 0000 		lds r24,seq_num_mux
 839 02a2 9091 0000 		lds r25,seq_num_mux+1
 840 02a6 0E94 0000 		call nrk_sem_post
 550:main.c        ****       seq_num++;
 842               	.LM83:
 843 02aa 8091 0000 		lds r24,seq_num
 844 02ae 9091 0000 		lds r25,seq_num+1
 845 02b2 0196      		adiw r24,1
 846 02b4 9093 0000 		sts seq_num+1,r25
 847 02b8 8093 0000 		sts seq_num,r24
 551:main.c        ****       tx_packet.seq_num = seq_num;
 849               	.LM84:
 850 02bc 9C83      		std Y+4,r25
 851 02be 8B83      		std Y+3,r24
 552:main.c        ****       nrk_sem_pend(seq_num_mux);
 853               	.LM85:
 854 02c0 8091 0000 		lds r24,seq_num_mux
 855 02c4 9091 0000 		lds r25,seq_num_mux+1
 856 02c8 0E94 0000 		call nrk_sem_pend
 553:main.c        **** 
 554:main.c        ****       // add data values to sensor packet
 555:main.c        ****       tx_packet.payload[DATA_PWR_INDEX] = sensor_pkt.pwr_val;
 858               	.LM86:
 859 02cc 8091 0000 		lds r24,sensor_pkt
 860 02d0 8A87      		std Y+10,r24
 556:main.c        ****       tx_packet.payload[DATA_TEMP_INDEX] = sensor_pkt.temp_val;
 862               	.LM87:
 863 02d2 8091 0000 		lds r24,sensor_pkt+2
 864 02d6 8C87      		std Y+12,r24
 557:main.c        ****       tx_packet.payload[DATA_LIGHT_INDEX] = sensor_pkt.light_val;
 866               	.LM88:
 867 02d8 8091 0000 		lds r24,sensor_pkt+4
 868 02dc 8E87      		std Y+14,r24
 558:main.c        **** 
 559:main.c        ****       // add packet to data queue
 560:main.c        ****       //nrk_sem_pend(data_tx_queue_mux);
 561:main.c        ****       //push(&data_tx_queue, &tx_packet);
 562:main.c        ****       //nrk_sem_post(data_tx_queue_mux);
 563:main.c        **** 
 564:main.c        ****       nrk_sem_pend(cmd_tx_queue_mux);
 870               	.LM89:
 871 02de 8091 0000 		lds r24,cmd_tx_queue_mux
 872 02e2 9091 0000 		lds r25,cmd_tx_queue_mux+1
 873 02e6 0E94 0000 		call nrk_sem_pend
 565:main.c        ****       push(&cmd_tx_queue, &tx_packet);
 875               	.LM90:
 876 02ea BE01      		movw r22,r28
 877 02ec 6F5F      		subi r22,-1
 878 02ee 7F4F      		sbci r23,-1
 879 02f0 80E0      		ldi r24,lo8(cmd_tx_queue)
 880 02f2 90E0      		ldi r25,hi8(cmd_tx_queue)
 881 02f4 0E94 0000 		call push
 566:main.c        ****       nrk_sem_post(data_tx_queue_mux);
 883               	.LM91:
 884 02f8 8091 0000 		lds r24,data_tx_queue_mux
 885 02fc 9091 0000 		lds r25,data_tx_queue_mux+1
 886 0300 0E94 0000 		call nrk_sem_post
 887               	.L33:
 567:main.c        **** 
 568:main.c        ****       // reset FLAG
 569:main.c        ****       sensor_sampled = FALSE;
 570:main.c        ****     }
 571:main.c        ****     nrk_wait_until_next_period();
 889               	.LM92:
 890 0304 0E94 0000 		call nrk_wait_until_next_period
 572:main.c        ****   }
 892               	.LM93:
 893 0308 00C0      		rjmp .L34
 902               	.Lscope2:
 904               		.stabd	78,0,0
 906               	.global	actuate_task
 908               	actuate_task:
 909               		.stabd	46,0,0
 573:main.c        **** }
 574:main.c        **** 
 575:main.c        **** /**
 576:main.c        ****  * actuate_task() - 
 577:main.c        ****  *  actuate any commands that have been received for this node.
 578:main.c        ****  */
 579:main.c        **** void actuate_task() {
 911               	.LM94:
 912               	.LFBB3:
 913 030a CF93      		push r28
 914 030c DF93      		push r29
 915 030e CDB7      		in r28,__SP_L__
 916 0310 DEB7      		in r29,__SP_H__
 917 0312 A297      		sbiw r28,34
 918 0314 0FB6      		in __tmp_reg__,__SREG__
 919 0316 F894      		cli
 920 0318 DEBF      		out __SP_H__,r29
 921 031a 0FBE      		out __SREG__,__tmp_reg__
 922 031c CDBF      		out __SP_L__,r28
 923               	/* prologue: function */
 924               	/* frame size = 34 */
 925               	/* stack size = 36 */
 926               	.L__stack_usage = 36
 580:main.c        ****   // local variable instantiation
 581:main.c        ****   uint8_t LED_FLAG = 0;
 582:main.c        ****   uint8_t act_queue_size;
 583:main.c        ****   packet act_packet, tx_packet;
 584:main.c        ****   uint8_t action, ack_required, act_required; 
 585:main.c        **** 
 586:main.c        ****   // initialize tx_packet
 587:main.c        ****   tx_packet.source_id = MAC_ADDR;
 928               	.LM95:
 929 031e 82E0      		ldi r24,lo8(2)
 930 0320 8983      		std Y+1,r24
 588:main.c        ****   tx_packet.type = MSG_CMDACK;
 932               	.LM96:
 933 0322 87E0      		ldi r24,lo8(7)
 934 0324 8A83      		std Y+2,r24
 589:main.c        ****   tx_packet.num_hops = 0;
 936               	.LM97:
 937 0326 1D82      		std Y+5,__zero_reg__
 581:main.c        ****   uint8_t act_queue_size;
 939               	.LM98:
 940 0328 00E0      		ldi r16,0
 941               	.LBB2:
 590:main.c        **** 
 591:main.c        ****   // loop forever
 592:main.c        ****   while(1) {
 593:main.c        ****     // LEDs for debug
 594:main.c        ****     if(blink_leds == BLINKLEDS) {
 595:main.c        ****       LED_FLAG++;
 596:main.c        ****       LED_FLAG%=2;
 597:main.c        ****       if(LED_FLAG == 0) {
 598:main.c        ****         //nrk_led_set(1);
 599:main.c        ****       } else {
 600:main.c        ****         nrk_led_clr(1);
 601:main.c        ****       }   
 602:main.c        ****     }
 603:main.c        **** 
 604:main.c        ****     // get action queue size
 605:main.c        ****     nrk_sem_post(act_queue_mux);
 606:main.c        ****     act_queue_size = act_queue.size;
 607:main.c        ****     nrk_sem_pend(act_queue_mux);
 608:main.c        **** 
 609:main.c        ****     /**
 610:main.c        ****      * loop on queue size received above, and no more.
 611:main.c        ****      *  NOTE: during this loop the queue can be added to. If, for instance,
 612:main.c        ****      *    a "while(act_queue.size > 0)" was used a few bad things could happen
 613:main.c        ****      *      (1) a mutex would be required around the entire loop - BAD IDEA
 614:main.c        ****      *      (2) the queue could be added to while this loop is running, thus
 615:main.c        ****      *        making the loop unbounded - BAD IDEA
 616:main.c        ****      *      (3) the size the queue read and the actual size of the queue could be 
 617:main.c        ****      *        incorrect due to preemtion - BAD IDEA
 618:main.c        ****      *    Doing it this way bounds this loop to the maximum size of the queue
 619:main.c        ****      *    at any given time, regardless of whether or not the queue has been 
 620:main.c        ****      *    added to by another task.
 621:main.c        ****      */
 622:main.c        ****     for(uint8_t i = 0; i < act_queue_size; i++) {
 623:main.c        ****       // get packet out of the queue
 624:main.c        ****       nrk_sem_post(act_queue_mux);
 625:main.c        ****       pop(&act_queue, &act_packet);
 626:main.c        ****       nrk_sem_pend(act_queue_mux); 
 627:main.c        **** 
 628:main.c        ****       // pull action out of packet
 629:main.c        ****       action = act_packet.payload[CMD_ACT_INDEX];
 630:main.c        **** 
 631:main.c        ****       // switch on current state
 632:main.c        ****       switch(curr_state) {
 633:main.c        ****         // STATE_ON - actuate if required / acknowledge if required
 634:main.c        ****         case STATE_ON:
 635:main.c        ****           // action ON received -> ack but don't act
 636:main.c        ****           if(action == ON) {
 637:main.c        ****             ack_required = TRUE;
 638:main.c        ****             act_required = FALSE;
 639:main.c        ****             curr_state = STATE_ON;
 640:main.c        ****           } 
 641:main.c        ****           // action OFF received -> ack and act
 642:main.c        ****           else if(action == OFF) {
 643:main.c        ****             ack_required = TRUE;
 644:main.c        ****             act_required = TRUE;
 645:main.c        ****             curr_state = STATE_OFF;
 646:main.c        ****           } 
 647:main.c        ****           // this should never happen, but -> don't ack and don't act
 648:main.c        ****           else {
 649:main.c        ****             ack_required = FALSE;
 650:main.c        ****             act_required = FALSE;
 651:main.c        ****             curr_state = STATE_ON;
 652:main.c        ****           }
 653:main.c        ****           break;        
 654:main.c        ****         // STATE_OFF - actuate if required / acknowledge if required
 655:main.c        ****         case STATE_OFF:
 656:main.c        ****           // action OFF received -> ack but don't act
 657:main.c        ****           if(action == OFF) {
 658:main.c        ****             ack_required = TRUE;
 659:main.c        ****             act_required = FALSE;
 660:main.c        ****             curr_state = STATE_OFF;
 661:main.c        ****           } 
 662:main.c        ****           // action ON received -> ack and act
 663:main.c        ****           else if(action == ON) {
 664:main.c        ****             ack_required = TRUE;
 665:main.c        ****             act_required = TRUE;
 666:main.c        ****             curr_state = STATE_ON;
 667:main.c        ****           } 
 668:main.c        ****           // this should never happen, but -> don't ack and don't act
 669:main.c        ****           else {
 670:main.c        ****             ack_required = FALSE;
 671:main.c        ****             act_required = FALSE;
 672:main.c        ****             curr_state = STATE_OFF;
 673:main.c        ****           }
 674:main.c        ****           break;
 675:main.c        ****         default:
 676:main.c        ****           // THIS SHOULD NEVER HAPPEN.
 677:main.c        ****           break;
 678:main.c        ****       }
 679:main.c        **** 
 680:main.c        ****       // action required -> complete actuation
 681:main.c        ****       if(act_required == TRUE) {
 682:main.c        ****         // TODO: ACTUATE.
 683:main.c        ****         // dummy operation so the compiler doesn't yell.
 684:main.c        ****         i = i;
 685:main.c        ****       }
 686:main.c        **** 
 687:main.c        ****       // acknowledge required -> add ack packet to cmd_tx_queue
 688:main.c        ****       if(ack_required == TRUE) {
 689:main.c        ****         // update sequence number
 690:main.c        ****         nrk_sem_pend(seq_num_mux);
 691:main.c        ****         seq_num++;
 692:main.c        ****         tx_packet.seq_num = seq_num;
 693:main.c        ****         nrk_sem_post(seq_num_mux);
 694:main.c        **** 
 695:main.c        ****         // set payload
 696:main.c        ****         tx_packet.payload[CMDACK_ID_INDEX] = act_packet.payload[CMD_ID_INDEX];
 697:main.c        **** 
 698:main.c        ****         // place message in the queue
 699:main.c        ****         nrk_sem_pend(cmd_tx_queue_mux);
 700:main.c        ****         push(&cmd_tx_queue, &tx_packet);
 701:main.c        ****         nrk_sem_post(cmd_tx_queue_mux);
 943               	.LM99:
 944 032a DD24      		clr r13
 945 032c D394      		inc r13
 946               	.L56:
 947               	.LBE2:
 594:main.c        ****       LED_FLAG++;
 949               	.LM100:
 950 032e 8091 0000 		lds r24,blink_leds
 951 0332 8130      		cpi r24,lo8(1)
 952 0334 01F4      		brne .L43
 595:main.c        ****       LED_FLAG%=2;
 954               	.LM101:
 955 0336 800F      		add r24,r16
 597:main.c        ****         //nrk_led_set(1);
 957               	.LM102:
 958 0338 082F      		mov r16,r24
 959 033a 0170      		andi r16,lo8(1)
 960 033c 80FF      		sbrs r24,0
 961 033e 00C0      		rjmp .L43
 600:main.c        ****       }   
 963               	.LM103:
 964 0340 81E0      		ldi r24,lo8(1)
 965 0342 90E0      		ldi r25,0
 966 0344 0E94 0000 		call nrk_led_clr
 967 0348 01E0      		ldi r16,lo8(1)
 968               	.L43:
 605:main.c        ****     act_queue_size = act_queue.size;
 970               	.LM104:
 971 034a 8091 0000 		lds r24,act_queue_mux
 972 034e 9091 0000 		lds r25,act_queue_mux+1
 973 0352 0E94 0000 		call nrk_sem_post
 606:main.c        ****     nrk_sem_pend(act_queue_mux);
 975               	.LM105:
 976 0356 E090 0000 		lds r14,act_queue+138
 607:main.c        **** 
 978               	.LM106:
 979 035a 8091 0000 		lds r24,act_queue_mux
 980 035e 9091 0000 		lds r25,act_queue_mux+1
 981 0362 0E94 0000 		call nrk_sem_pend
 982               	.LBB3:
 622:main.c        ****       // get packet out of the queue
 984               	.LM107:
 985 0366 F12C      		mov r15,__zero_reg__
 986               	.L44:
 622:main.c        ****       // get packet out of the queue
 988               	.LM108:
 989 0368 FE14      		cp r15,r14
 990 036a 01F4      		brne .+2
 991 036c 00C0      		rjmp .L69
 624:main.c        ****       pop(&act_queue, &act_packet);
 993               	.LM109:
 994 036e 8091 0000 		lds r24,act_queue_mux
 995 0372 9091 0000 		lds r25,act_queue_mux+1
 996 0376 0E94 0000 		call nrk_sem_post
 625:main.c        ****       nrk_sem_pend(act_queue_mux); 
 998               	.LM110:
 999 037a BE01      		movw r22,r28
 1000 037c 6E5E      		subi r22,-18
 1001 037e 7F4F      		sbci r23,-1
 1002 0380 80E0      		ldi r24,lo8(act_queue)
 1003 0382 90E0      		ldi r25,hi8(act_queue)
 1004 0384 0E94 0000 		call pop
 626:main.c        **** 
 1006               	.LM111:
 1007 0388 8091 0000 		lds r24,act_queue_mux
 1008 038c 9091 0000 		lds r25,act_queue_mux+1
 1009 0390 0E94 0000 		call nrk_sem_pend
 629:main.c        **** 
 1011               	.LM112:
 1012 0394 8E8D      		ldd r24,Y+30
 632:main.c        ****         // STATE_ON - actuate if required / acknowledge if required
 1014               	.LM113:
 1015 0396 9091 0000 		lds r25,curr_state
 1016 039a 9923      		tst r25
 1017 039c 01F0      		breq .L46
 1018 039e 9130      		cpi r25,lo8(1)
 1019 03a0 01F0      		breq .L47
 1020 03a2 00C0      		rjmp .L70
 1021               	.L46:
 636:main.c        ****             ack_required = TRUE;
 1023               	.LM114:
 1024 03a4 8130      		cpi r24,lo8(1)
 1025 03a6 01F4      		brne .L48
 1026               	.L53:
 639:main.c        ****           } 
 1028               	.LM115:
 1029 03a8 1092 0000 		sts curr_state,__zero_reg__
 1030 03ac 00C0      		rjmp .L57
 1031               	.L48:
 642:main.c        ****             ack_required = TRUE;
 1033               	.LM116:
 1034 03ae 8111      		cpse r24,__zero_reg__
 1035 03b0 00C0      		rjmp .L50
 1036               	.L52:
 645:main.c        ****           } 
 1038               	.LM117:
 1039 03b2 D092 0000 		sts curr_state,r13
 1040 03b6 00C0      		rjmp .L57
 1041               	.L50:
 651:main.c        ****           }
 1043               	.LM118:
 1044 03b8 1092 0000 		sts curr_state,__zero_reg__
 1045 03bc 00C0      		rjmp .L58
 1046               	.L47:
 657:main.c        ****             ack_required = TRUE;
 1048               	.LM119:
 1049 03be 8823      		tst r24
 1050 03c0 01F0      		breq .L52
 663:main.c        ****             ack_required = TRUE;
 1052               	.LM120:
 1053 03c2 8130      		cpi r24,lo8(1)
 1054 03c4 01F0      		breq .L53
 672:main.c        ****           }
 1056               	.LM121:
 1057 03c6 9093 0000 		sts curr_state,r25
 1058 03ca 00C0      		rjmp .L58
 1059               	.L70:
 688:main.c        ****         // update sequence number
 1061               	.LM122:
 1062 03cc 1130      		cpi r17,lo8(1)
 1063 03ce 01F4      		brne .L58
 1064               	.L57:
 690:main.c        ****         seq_num++;
 1066               	.LM123:
 1067 03d0 8091 0000 		lds r24,seq_num_mux
 1068 03d4 9091 0000 		lds r25,seq_num_mux+1
 1069 03d8 0E94 0000 		call nrk_sem_pend
 691:main.c        ****         tx_packet.seq_num = seq_num;
 1071               	.LM124:
 1072 03dc 8091 0000 		lds r24,seq_num
 1073 03e0 9091 0000 		lds r25,seq_num+1
 1074 03e4 0196      		adiw r24,1
 1075 03e6 9093 0000 		sts seq_num+1,r25
 1076 03ea 8093 0000 		sts seq_num,r24
 692:main.c        ****         nrk_sem_post(seq_num_mux);
 1078               	.LM125:
 1079 03ee 9C83      		std Y+4,r25
 1080 03f0 8B83      		std Y+3,r24
 693:main.c        **** 
 1082               	.LM126:
 1083 03f2 8091 0000 		lds r24,seq_num_mux
 1084 03f6 9091 0000 		lds r25,seq_num_mux+1
 1085 03fa 0E94 0000 		call nrk_sem_post
 696:main.c        **** 
 1087               	.LM127:
 1088 03fe 8B8D      		ldd r24,Y+27
 1089 0400 8A87      		std Y+10,r24
 699:main.c        ****         push(&cmd_tx_queue, &tx_packet);
 1091               	.LM128:
 1092 0402 8091 0000 		lds r24,cmd_tx_queue_mux
 1093 0406 9091 0000 		lds r25,cmd_tx_queue_mux+1
 1094 040a 0E94 0000 		call nrk_sem_pend
 700:main.c        ****         nrk_sem_post(cmd_tx_queue_mux);
 1096               	.LM129:
 1097 040e BE01      		movw r22,r28
 1098 0410 6F5F      		subi r22,-1
 1099 0412 7F4F      		sbci r23,-1
 1100 0414 80E0      		ldi r24,lo8(cmd_tx_queue)
 1101 0416 90E0      		ldi r25,hi8(cmd_tx_queue)
 1102 0418 0E94 0000 		call push
 1104               	.LM130:
 1105 041c 8091 0000 		lds r24,cmd_tx_queue_mux
 1106 0420 9091 0000 		lds r25,cmd_tx_queue_mux+1
 1107 0424 0E94 0000 		call nrk_sem_post
 1108 0428 11E0      		ldi r17,lo8(1)
 1109 042a 00C0      		rjmp .L54
 1110               	.L58:
 1111 042c 10E0      		ldi r17,0
 1112               	.L54:
 622:main.c        ****       // get packet out of the queue
 1114               	.LM131:
 1115 042e F394      		inc r15
 1116 0430 00C0      		rjmp .L44
 1117               	.L69:
 1118               	.LBE3:
 702:main.c        ****       }
 703:main.c        ****     }
 704:main.c        ****     nrk_wait_until_next_period();
 1120               	.LM132:
 1121 0432 0E94 0000 		call nrk_wait_until_next_period
 705:main.c        ****   }
 1123               	.LM133:
 1124 0436 00C0      		rjmp .L56
 1139               	.Lscope3:
 1141               		.stabd	78,0,0
 1143               	.global	clear_tx_buf
 1145               	clear_tx_buf:
 1146               		.stabd	46,0,0
 147:main.c        ****   for(uint8_t i = 0; i < net_tx_index; i++)
 1148               	.LM134:
 1149               	.LFBB4:
 1150               	/* prologue: function */
 1151               	/* frame size = 0 */
 1152               	/* stack size = 0 */
 1153               	.L__stack_usage = 0
 1154               	.LBB4:
 148:main.c        ****   {
 1156               	.LM135:
 1157 0438 8091 0000 		lds r24,net_tx_index
 1158 043c 20E0      		ldi r18,lo8(net_tx_buf)
 1159 043e 30E0      		ldi r19,hi8(net_tx_buf)
 1160 0440 F901      		movw r30,r18
 1161               	.L72:
 1162 0442 9E2F      		mov r25,r30
 1163 0444 921B      		sub r25,r18
 148:main.c        ****   {
 1165               	.LM136:
 1166 0446 9817      		cp r25,r24
 1167 0448 00F4      		brsh .L74
 150:main.c        ****   }
 1169               	.LM137:
 1170 044a 1192      		st Z+,__zero_reg__
 1171 044c 00C0      		rjmp .L72
 1172               	.L74:
 1173               	.LBE4:
 152:main.c        **** }
 1175               	.LM138:
 1176 044e 1092 0000 		sts net_tx_index,__zero_reg__
 1177 0452 0895      		ret
 1179               	.Lscope4:
 1181               		.stabd	78,0,0
 1182               		.section	.rodata.str1.1,"aMS",@progbits,1
 1183               	.LC0:
 1184 0000 7478 2070 		.string	"tx pkt: %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n"
 1184      6B74 3A20 
 1184      2564 2C25 
 1184      642C 2564 
 1184      2C25 642C 
 1185               		.text
 1187               	.global	tx_cmd_task
 1189               	tx_cmd_task:
 1190               		.stabd	46,0,0
 299:main.c        ****   // local variable instantiation
 1192               	.LM139:
 1193               	.LFBB5:
 1194 0454 CF93      		push r28
 1195 0456 DF93      		push r29
 1196 0458 CDB7      		in r28,__SP_L__
 1197 045a DEB7      		in r29,__SP_H__
 1198 045c 6197      		sbiw r28,17
 1199 045e 0FB6      		in __tmp_reg__,__SREG__
 1200 0460 F894      		cli
 1201 0462 DEBF      		out __SP_H__,r29
 1202 0464 0FBE      		out __SREG__,__tmp_reg__
 1203 0466 CDBF      		out __SP_L__,r28
 1204               	/* prologue: function */
 1205               	/* frame size = 17 */
 1206               	/* stack size = 19 */
 1207               	.L__stack_usage = 19
 1208               	.L76:
 310:main.c        ****     nrk_wait_until_next_period();
 1210               	.LM140:
 1211 0468 0E94 0000 		call bmac_started
 1212 046c 8111      		cpse r24,__zero_reg__
 1213 046e 00C0      		rjmp .L89
 311:main.c        ****   }
 1215               	.LM141:
 1216 0470 0E94 0000 		call nrk_wait_until_next_period
 1217 0474 00C0      		rjmp .L76
 1218               	.L89:
 315:main.c        ****   nrk_signal_register(tx_done_signal);
 1220               	.LM142:
 1221 0476 0E94 0000 		call bmac_get_tx_done_signal
 1222 047a 182F      		mov r17,r24
 316:main.c        **** 
 1224               	.LM143:
 1225 047c 0E94 0000 		call nrk_signal_register
 1226               	.LBB5:
 363:main.c        **** 
 1228               	.LM144:
 1229 0480 C12C      		mov r12,__zero_reg__
 1230 0482 D12C      		mov r13,__zero_reg__
 1231 0484 7601      		movw r14,r12
 1232 0486 C394      		inc r12
 1233 0488 00C0      		rjmp 2f
 1234               		1:
 1235 048a CC0C      		lsl r12
 1236 048c DD1C      		rol r13
 1237 048e EE1C      		rol r14
 1238 0490 FF1C      		rol r15
 1239               		2:
 1240 0492 1A95      		dec r17
 1241 0494 02F4      		brpl 1b
 370:main.c        ****         nrk_kprintf (PSTR ("TX done signal error\r\n"));
 1243               	.LM145:
 1244 0496 812C      		mov r8,__zero_reg__
 1245 0498 912C      		mov r9,__zero_reg__
 1246 049a 5401      		movw r10,r8
 1247 049c 8394      		inc r8
 1248 049e C114      		cp r12,__zero_reg__
 1249 04a0 D104      		cpc r13,__zero_reg__
 1250 04a2 E104      		cpc r14,__zero_reg__
 1251 04a4 F104      		cpc r15,__zero_reg__
 1252 04a6 01F0      		breq .L78
 1253 04a8 812C      		mov r8,__zero_reg__
 1254 04aa 912C      		mov r9,__zero_reg__
 1255 04ac 5401      		movw r10,r8
 1256               	.L78:
 365:main.c        ****         net_tx_buf[0],net_tx_buf[1],net_tx_buf[2],net_tx_buf[3],net_tx_buf[4],
 1258               	.LM146:
 1259 04ae 80E0      		ldi r24,lo8(.LC0)
 1260 04b0 282E      		mov r2,r24
 1261 04b2 80E0      		ldi r24,hi8(.LC0)
 1262 04b4 382E      		mov r3,r24
 1263               	.L82:
 1264               	.LBE5:
 333:main.c        ****       tx_cmd_queue_size = cmd_tx_queue.size;
 1266               	.LM147:
 1267 04b6 8091 0000 		lds r24,cmd_tx_queue_mux
 1268 04ba 9091 0000 		lds r25,cmd_tx_queue_mux+1
 1269 04be 0E94 0000 		call nrk_sem_pend
 334:main.c        ****     nrk_sem_post(cmd_tx_queue_mux);
 1271               	.LM148:
 1272 04c2 0091 0000 		lds r16,cmd_tx_queue+138
 335:main.c        **** 
 1274               	.LM149:
 1275 04c6 8091 0000 		lds r24,cmd_tx_queue_mux
 1276 04ca 9091 0000 		lds r25,cmd_tx_queue_mux+1
 1277 04ce 0E94 0000 		call nrk_sem_post
 1278               	.LBB6:
 350:main.c        ****       // get a packet out of the queue.
 1280               	.LM150:
 1281 04d2 10E0      		ldi r17,0
 1282               	.L79:
 350:main.c        ****       // get a packet out of the queue.
 1284               	.LM151:
 1285 04d4 1017      		cp r17,r16
 1286 04d6 01F4      		brne .+2
 1287 04d8 00C0      		rjmp .L90
 352:main.c        ****       pop(&cmd_tx_queue, &tx_packet);
 1289               	.LM152:
 1290 04da 8091 0000 		lds r24,cmd_tx_queue_mux
 1291 04de 9091 0000 		lds r25,cmd_tx_queue_mux+1
 1292 04e2 0E94 0000 		call nrk_sem_pend
 353:main.c        ****       nrk_sem_post(cmd_tx_queue_mux);
 1294               	.LM153:
 1295 04e6 BE01      		movw r22,r28
 1296 04e8 6F5F      		subi r22,-1
 1297 04ea 7F4F      		sbci r23,-1
 1298 04ec 80E0      		ldi r24,lo8(cmd_tx_queue)
 1299 04ee 90E0      		ldi r25,hi8(cmd_tx_queue)
 1300 04f0 0E94 0000 		call pop
 354:main.c        **** 
 1302               	.LM154:
 1303 04f4 8091 0000 		lds r24,cmd_tx_queue_mux
 1304 04f8 9091 0000 		lds r25,cmd_tx_queue_mux+1
 1305 04fc 0E94 0000 		call nrk_sem_post
 358:main.c        ****       net_tx_index = assemble_packet(&net_tx_buf, &tx_packet);
 1307               	.LM155:
 1308 0500 8091 0000 		lds r24,net_tx_buf_mux
 1309 0504 9091 0000 		lds r25,net_tx_buf_mux+1
 1310 0508 0E94 0000 		call nrk_sem_pend
 359:main.c        **** 
 1312               	.LM156:
 1313 050c BE01      		movw r22,r28
 1314 050e 6F5F      		subi r22,-1
 1315 0510 7F4F      		sbci r23,-1
 1316 0512 80E0      		ldi r24,lo8(net_tx_buf)
 1317 0514 90E0      		ldi r25,hi8(net_tx_buf)
 1318 0516 0E94 0000 		call assemble_packet
 1319 051a 8093 0000 		sts net_tx_index,r24
 362:main.c        ****       ret = nrk_event_wait (SIG(tx_done_signal));
 1321               	.LM157:
 1322 051e 682F      		mov r22,r24
 1323 0520 80E0      		ldi r24,lo8(net_tx_buf)
 1324 0522 90E0      		ldi r25,hi8(net_tx_buf)
 1325 0524 0E94 0000 		call bmac_tx_pkt_nonblocking
 363:main.c        **** 
 1327               	.LM158:
 1328 0528 C701      		movw r24,r14
 1329 052a B601      		movw r22,r12
 1330 052c 0E94 0000 		call nrk_event_wait
 1331 0530 2B01      		movw r4,r22
 1332 0532 3C01      		movw r6,r24
 365:main.c        ****         net_tx_buf[0],net_tx_buf[1],net_tx_buf[2],net_tx_buf[3],net_tx_buf[4],
 1334               	.LM159:
 1335 0534 8091 0000 		lds r24,net_tx_buf+9
 1336 0538 1F92      		push __zero_reg__
 1337 053a 8F93      		push r24
 1338 053c 8091 0000 		lds r24,net_tx_buf+8
 1339 0540 1F92      		push __zero_reg__
 1340 0542 8F93      		push r24
 1341 0544 8091 0000 		lds r24,net_tx_buf+7
 1342 0548 1F92      		push __zero_reg__
 1343 054a 8F93      		push r24
 1344 054c 8091 0000 		lds r24,net_tx_buf+6
 1345 0550 1F92      		push __zero_reg__
 1346 0552 8F93      		push r24
 1347 0554 8091 0000 		lds r24,net_tx_buf+5
 1348 0558 1F92      		push __zero_reg__
 1349 055a 8F93      		push r24
 1350 055c 8091 0000 		lds r24,net_tx_buf+4
 1351 0560 1F92      		push __zero_reg__
 1352 0562 8F93      		push r24
 1353 0564 8091 0000 		lds r24,net_tx_buf+3
 1354 0568 1F92      		push __zero_reg__
 1355 056a 8F93      		push r24
 1356 056c 8091 0000 		lds r24,net_tx_buf+2
 1357 0570 1F92      		push __zero_reg__
 1358 0572 8F93      		push r24
 1359 0574 8091 0000 		lds r24,net_tx_buf+1
 1360 0578 1F92      		push __zero_reg__
 1361 057a 8F93      		push r24
 1362 057c 8091 0000 		lds r24,net_tx_buf
 1363 0580 1F92      		push __zero_reg__
 1364 0582 8F93      		push r24
 1365 0584 3F92      		push r3
 1366 0586 2F92      		push r2
 1367 0588 0E94 0000 		call printf
 370:main.c        ****         nrk_kprintf (PSTR ("TX done signal error\r\n"));
 1369               	.LM160:
 1370 058c 4820      		and r4,r8
 1371 058e 5920      		and r5,r9
 1372 0590 6A20      		and r6,r10
 1373 0592 7B20      		and r7,r11
 1374 0594 0FB6      		in __tmp_reg__,__SREG__
 1375 0596 F894      		cli
 1376 0598 DEBF      		out __SP_H__,r29
 1377 059a 0FBE      		out __SREG__,__tmp_reg__
 1378 059c CDBF      		out __SP_L__,r28
 1379 059e 4528      		or r4,r5
 1380 05a0 4628      		or r4,r6
 1381 05a2 4728      		or r4,r7
 1382 05a4 01F0      		breq .L80
 371:main.c        ****       }
 1384               	.LM161:
 1385 05a6 80E0      		ldi r24,lo8(__c.3855)
 1386 05a8 90E0      		ldi r25,hi8(__c.3855)
 1387 05aa 0E94 0000 		call nrk_kprintf
 1388               	.L80:
 373:main.c        ****       nrk_sem_post(net_tx_buf_mux);     
 1390               	.LM162:
 1391 05ae 0E94 0000 		call clear_tx_buf
 374:main.c        ****     }
 1393               	.LM163:
 1394 05b2 8091 0000 		lds r24,net_tx_buf_mux
 1395 05b6 9091 0000 		lds r25,net_tx_buf_mux+1
 1396 05ba 0E94 0000 		call nrk_sem_post
 350:main.c        ****       // get a packet out of the queue.
 1398               	.LM164:
 1399 05be 1F5F      		subi r17,lo8(-(1))
 1400 05c0 00C0      		rjmp .L79
 1401               	.L90:
 1402               	.LBE6:
 376:main.c        ****   }
 1404               	.LM165:
 1405 05c2 0E94 0000 		call nrk_wait_until_next_period
 377:main.c        **** }
 1407               	.LM166:
 1408 05c6 00C0      		rjmp .L82
 1422               	.Lscope5:
 1424               		.stabd	78,0,0
 1426               	.global	tx_data_task
 1428               	tx_data_task:
 1429               		.stabd	46,0,0
 384:main.c        ****   // local variable initialization
 1431               	.LM167:
 1432               	.LFBB6:
 1433 05c8 CF93      		push r28
 1434 05ca DF93      		push r29
 1435 05cc CDB7      		in r28,__SP_L__
 1436 05ce DEB7      		in r29,__SP_H__
 1437 05d0 6197      		sbiw r28,17
 1438 05d2 0FB6      		in __tmp_reg__,__SREG__
 1439 05d4 F894      		cli
 1440 05d6 DEBF      		out __SP_H__,r29
 1441 05d8 0FBE      		out __SREG__,__tmp_reg__
 1442 05da CDBF      		out __SP_L__,r28
 1443               	/* prologue: function */
 1444               	/* frame size = 17 */
 1445               	/* stack size = 19 */
 1446               	.L__stack_usage = 19
 1447               	.L92:
 395:main.c        ****     nrk_wait_until_next_period ();
 1449               	.LM168:
 1450 05dc 0E94 0000 		call bmac_started
 1451 05e0 8111      		cpse r24,__zero_reg__
 1452 05e2 00C0      		rjmp .L107
 396:main.c        ****   }
 1454               	.LM169:
 1455 05e4 0E94 0000 		call nrk_wait_until_next_period
 1456 05e8 00C0      		rjmp .L92
 1457               	.L107:
 400:main.c        ****   nrk_signal_register(tx_done_signal);
 1459               	.LM170:
 1460 05ea 0E94 0000 		call bmac_get_tx_done_signal
 1461 05ee 182F      		mov r17,r24
 401:main.c        ****   
 1463               	.LM171:
 1464 05f0 0E94 0000 		call nrk_signal_register
 1465               	.LBB7:
 452:main.c        **** 
 1467               	.LM172:
 1468 05f4 C12C      		mov r12,__zero_reg__
 1469 05f6 D12C      		mov r13,__zero_reg__
 1470 05f8 7601      		movw r14,r12
 1471 05fa C394      		inc r12
 1472 05fc 00C0      		rjmp 2f
 1473               		1:
 1474 05fe CC0C      		lsl r12
 1475 0600 DD1C      		rol r13
 1476 0602 EE1C      		rol r14
 1477 0604 FF1C      		rol r15
 1478               		2:
 1479 0606 1A95      		dec r17
 1480 0608 02F4      		brpl 1b
 461:main.c        ****         nrk_kprintf (PSTR ("TX done signal error\r\n"));
 1482               	.LM173:
 1483 060a 812C      		mov r8,__zero_reg__
 1484 060c 912C      		mov r9,__zero_reg__
 1485 060e 5401      		movw r10,r8
 1486 0610 8394      		inc r8
 1487 0612 C114      		cp r12,__zero_reg__
 1488 0614 D104      		cpc r13,__zero_reg__
 1489 0616 E104      		cpc r14,__zero_reg__
 1490 0618 F104      		cpc r15,__zero_reg__
 1491 061a 01F0      		breq .L94
 1492 061c 812C      		mov r8,__zero_reg__
 1493 061e 912C      		mov r9,__zero_reg__
 1494 0620 5401      		movw r10,r8
 1495               	.L94:
 1496               	.LBE7:
 386:main.c        ****   uint16_t val;
 1498               	.LM174:
 1499 0622 10E0      		ldi r17,0
 1500               	.L100:
 405:main.c        ****       LED_FLAG++;
 1502               	.LM175:
 1503 0624 8091 0000 		lds r24,blink_leds
 1504 0628 8130      		cpi r24,lo8(1)
 1505 062a 01F4      		brne .L95
 406:main.c        ****       LED_FLAG%=2;
 1507               	.LM176:
 1508 062c 810F      		add r24,r17
 408:main.c        ****         nrk_led_set(3);
 1510               	.LM177:
 1511 062e 182F      		mov r17,r24
 1512 0630 1170      		andi r17,lo8(1)
 1513 0632 80FD      		sbrc r24,0
 1514 0634 00C0      		rjmp .L96
 409:main.c        ****       } else {
 1516               	.LM178:
 1517 0636 83E0      		ldi r24,lo8(3)
 1518 0638 90E0      		ldi r25,0
 1519 063a 0E94 0000 		call nrk_led_set
 1520 063e 00C0      		rjmp .L95
 1521               	.L96:
 411:main.c        ****       }      
 1523               	.LM179:
 1524 0640 83E0      		ldi r24,lo8(3)
 1525 0642 90E0      		ldi r25,0
 1526 0644 0E94 0000 		call nrk_led_clr
 1527 0648 11E0      		ldi r17,lo8(1)
 1528               	.L95:
 416:main.c        ****       tx_data_queue_size = data_tx_queue.size;
 1530               	.LM180:
 1531 064a 8091 0000 		lds r24,data_tx_queue_mux
 1532 064e 9091 0000 		lds r25,data_tx_queue_mux+1
 1533 0652 0E94 0000 		call nrk_sem_pend
 417:main.c        ****     nrk_sem_post(data_tx_queue_mux);
 1535               	.LM181:
 1536 0656 7090 0000 		lds r7,data_tx_queue+138
 418:main.c        **** 
 1538               	.LM182:
 1539 065a 8091 0000 		lds r24,data_tx_queue_mux
 1540 065e 9091 0000 		lds r25,data_tx_queue_mux+1
 1541 0662 0E94 0000 		call nrk_sem_post
 1542               	.LBB8:
 433:main.c        ****       // get a packet out of the queue.
 1544               	.LM183:
 1545 0666 00E0      		ldi r16,0
 1546               	.L97:
 433:main.c        ****       // get a packet out of the queue.
 1548               	.LM184:
 1549 0668 0715      		cp r16,r7
 1550 066a 01F4      		brne .+2
 1551 066c 00C0      		rjmp .L108
 435:main.c        ****      // printf("Q front:%d\r\n", data_tx_queue.front);// for debug
 1553               	.LM185:
 1554 066e 8091 0000 		lds r24,data_tx_queue_mux
 1555 0672 9091 0000 		lds r25,data_tx_queue_mux+1
 1556 0676 0E94 0000 		call nrk_sem_pend
 437:main.c        ****       nrk_sem_post(data_tx_queue_mux);
 1558               	.LM186:
 1559 067a BE01      		movw r22,r28
 1560 067c 6F5F      		subi r22,-1
 1561 067e 7F4F      		sbci r23,-1
 1562 0680 80E0      		ldi r24,lo8(data_tx_queue)
 1563 0682 90E0      		ldi r25,hi8(data_tx_queue)
 1564 0684 0E94 0000 		call pop
 438:main.c        **** 
 1566               	.LM187:
 1567 0688 8091 0000 		lds r24,data_tx_queue_mux
 1568 068c 9091 0000 		lds r25,data_tx_queue_mux+1
 1569 0690 0E94 0000 		call nrk_sem_post
 447:main.c        ****       net_tx_index = assemble_packet(&net_tx_buf, &tx_packet);
 1571               	.LM188:
 1572 0694 8091 0000 		lds r24,net_tx_buf_mux
 1573 0698 9091 0000 		lds r25,net_tx_buf_mux+1
 1574 069c 0E94 0000 		call nrk_sem_pend
 448:main.c        **** 
 1576               	.LM189:
 1577 06a0 BE01      		movw r22,r28
 1578 06a2 6F5F      		subi r22,-1
 1579 06a4 7F4F      		sbci r23,-1
 1580 06a6 80E0      		ldi r24,lo8(net_tx_buf)
 1581 06a8 90E0      		ldi r25,hi8(net_tx_buf)
 1582 06aa 0E94 0000 		call assemble_packet
 1583 06ae 8093 0000 		sts net_tx_index,r24
 451:main.c        ****       ret = nrk_event_wait (SIG(tx_done_signal));
 1585               	.LM190:
 1586 06b2 682F      		mov r22,r24
 1587 06b4 80E0      		ldi r24,lo8(net_tx_buf)
 1588 06b6 90E0      		ldi r25,hi8(net_tx_buf)
 1589 06b8 0E94 0000 		call bmac_tx_pkt_nonblocking
 452:main.c        **** 
 1591               	.LM191:
 1592 06bc C701      		movw r24,r14
 1593 06be B601      		movw r22,r12
 1594 06c0 0E94 0000 		call nrk_event_wait
 461:main.c        ****         nrk_kprintf (PSTR ("TX done signal error\r\n"));
 1596               	.LM192:
 1597 06c4 DC01      		movw r26,r24
 1598 06c6 CB01      		movw r24,r22
 1599 06c8 8821      		and r24,r8
 1600 06ca 9921      		and r25,r9
 1601 06cc AA21      		and r26,r10
 1602 06ce BB21      		and r27,r11
 1603 06d0 892B      		or r24,r25
 1604 06d2 8A2B      		or r24,r26
 1605 06d4 8B2B      		or r24,r27
 1606 06d6 01F0      		breq .L98
 462:main.c        ****       }
 1608               	.LM193:
 1609 06d8 80E0      		ldi r24,lo8(__c.3873)
 1610 06da 90E0      		ldi r25,hi8(__c.3873)
 1611 06dc 0E94 0000 		call nrk_kprintf
 1612               	.L98:
 464:main.c        ****       nrk_sem_post(net_tx_buf_mux);     
 1614               	.LM194:
 1615 06e0 0E94 0000 		call clear_tx_buf
 465:main.c        ****     }
 1617               	.LM195:
 1618 06e4 8091 0000 		lds r24,net_tx_buf_mux
 1619 06e8 9091 0000 		lds r25,net_tx_buf_mux+1
 1620 06ec 0E94 0000 		call nrk_sem_post
 433:main.c        ****       // get a packet out of the queue.
 1622               	.LM196:
 1623 06f0 0F5F      		subi r16,lo8(-(1))
 1624 06f2 00C0      		rjmp .L97
 1625               	.L108:
 1626               	.LBE8:
 467:main.c        ****   }
 1628               	.LM197:
 1629 06f4 0E94 0000 		call nrk_wait_until_next_period
 468:main.c        **** }
 1631               	.LM198:
 1632 06f8 00C0      		rjmp .L100
 1646               	.Lscope6:
 1648               		.stabd	78,0,0
 1650               	.global	nrk_create_taskset
 1652               	nrk_create_taskset:
 1653               		.stabd	46,0,0
 706:main.c        **** }
 707:main.c        **** 
 708:main.c        **** /**
 709:main.c        ****  * nrk_create_taskset - create the tasks in this application
 710:main.c        ****  * 
 711:main.c        ****  * NOTE: task priority maps to importance. That is, priority(5) > priority(2).
 712:main.c        ****  */
 713:main.c        **** void nrk_create_taskset () {
 1655               	.LM199:
 1656               	.LFBB7:
 1657 06fa 4F92      		push r4
 1658 06fc 5F92      		push r5
 1659 06fe 6F92      		push r6
 1660 0700 7F92      		push r7
 1661 0702 8F92      		push r8
 1662 0704 9F92      		push r9
 1663 0706 AF92      		push r10
 1664 0708 BF92      		push r11
 1665 070a CF92      		push r12
 1666 070c DF92      		push r13
 1667 070e EF92      		push r14
 1668 0710 FF92      		push r15
 1669 0712 0F93      		push r16
 1670 0714 1F93      		push r17
 1671 0716 CF93      		push r28
 1672               	/* prologue: function */
 1673               	/* frame size = 0 */
 1674               	/* stack size = 15 */
 1675               	.L__stack_usage = 15
 714:main.c        ****   // PRIORITY 5
 715:main.c        ****   RX_MSG_TASK.task = rx_msg_task;
 1677               	.LM200:
 1678 0718 00E0      		ldi r16,lo8(RX_MSG_TASK)
 1679 071a 10E0      		ldi r17,hi8(RX_MSG_TASK)
 1680 071c 80E0      		ldi r24,lo8(gs(rx_msg_task))
 1681 071e 90E0      		ldi r25,hi8(gs(rx_msg_task))
 1682 0720 F801      		movw r30,r16
 1683 0722 9683      		std Z+6,r25
 1684 0724 8583      		std Z+5,r24
 716:main.c        ****   nrk_task_set_stk(&RX_MSG_TASK, rx_msg_task_stack, NRK_APP_STACKSIZE);
 1686               	.LM201:
 1687 0726 40E0      		ldi r20,0
 1688 0728 52E0      		ldi r21,lo8(2)
 1689 072a 60E0      		ldi r22,lo8(rx_msg_task_stack)
 1690 072c 70E0      		ldi r23,hi8(rx_msg_task_stack)
 1691 072e C801      		movw r24,r16
 1692 0730 0E94 0000 		call nrk_task_set_stk
 717:main.c        ****   RX_MSG_TASK.prio = 5;
 1694               	.LM202:
 1695 0734 85E0      		ldi r24,lo8(5)
 1696 0736 F801      		movw r30,r16
 1697 0738 8087      		std Z+8,r24
 718:main.c        ****   RX_MSG_TASK.FirstActivation = TRUE;
 1699               	.LM203:
 1700 073a C1E0      		ldi r28,lo8(1)
 1701 073c C783      		std Z+7,r28
 719:main.c        ****   RX_MSG_TASK.Type = BASIC_TASK;
 1703               	.LM204:
 1704 073e C187      		std Z+9,r28
 720:main.c        ****   RX_MSG_TASK.SchType = PREEMPTIVE;
 1706               	.LM205:
 1707 0740 C287      		std Z+10,r28
 721:main.c        ****   RX_MSG_TASK.period.secs = 0;
 1709               	.LM206:
 1710 0742 1386      		std Z+11,__zero_reg__
 1711 0744 1486      		std Z+12,__zero_reg__
 1712 0746 1586      		std Z+13,__zero_reg__
 1713 0748 1686      		std Z+14,__zero_reg__
 722:main.c        ****   RX_MSG_TASK.period.nano_secs = 100*NANOS_PER_MS;
 1715               	.LM207:
 1716 074a C12C      		mov r12,__zero_reg__
 1717 074c 81EE      		ldi r24,lo8(-31)
 1718 074e D82E      		mov r13,r24
 1719 0750 85EF      		ldi r24,lo8(-11)
 1720 0752 E82E      		mov r14,r24
 1721 0754 85E0      		ldi r24,lo8(5)
 1722 0756 F82E      		mov r15,r24
 1723 0758 C786      		std Z+15,r12
 1724 075a D08A      		std Z+16,r13
 1725 075c E18A      		std Z+17,r14
 1726 075e F28A      		std Z+18,r15
 723:main.c        ****   RX_MSG_TASK.cpu_reserve.secs = 0;
 1728               	.LM208:
 1729 0760 138A      		std Z+19,__zero_reg__
 1730 0762 148A      		std Z+20,__zero_reg__
 1731 0764 158A      		std Z+21,__zero_reg__
 1732 0766 168A      		std Z+22,__zero_reg__
 724:main.c        ****   RX_MSG_TASK.cpu_reserve.nano_secs = 20*NANOS_PER_MS;
 1734               	.LM209:
 1735 0768 412C      		mov r4,__zero_reg__
 1736 076a 9DE2      		ldi r25,lo8(45)
 1737 076c 592E      		mov r5,r25
 1738 076e 91E3      		ldi r25,lo8(49)
 1739 0770 692E      		mov r6,r25
 1740 0772 7724      		clr r7
 1741 0774 7394      		inc r7
 1742 0776 478A      		std Z+23,r4
 1743 0778 508E      		std Z+24,r5
 1744 077a 618E      		std Z+25,r6
 1745 077c 728E      		std Z+26,r7
 725:main.c        ****   RX_MSG_TASK.offset.secs = 0;
 1747               	.LM210:
 1748 077e 138E      		std Z+27,__zero_reg__
 1749 0780 148E      		std Z+28,__zero_reg__
 1750 0782 158E      		std Z+29,__zero_reg__
 1751 0784 168E      		std Z+30,__zero_reg__
 726:main.c        ****   RX_MSG_TASK.offset.nano_secs = 0;
 1753               	.LM211:
 1754 0786 178E      		std Z+31,__zero_reg__
 1755 0788 10A2      		std Z+32,__zero_reg__
 1756 078a 11A2      		std Z+33,__zero_reg__
 1757 078c 12A2      		std Z+34,__zero_reg__
 727:main.c        **** 
 728:main.c        ****   // PRIORITY 4
 729:main.c        ****   ACTUATE_TASK.task = actuate_task;
 1759               	.LM212:
 1760 078e 00E0      		ldi r16,lo8(ACTUATE_TASK)
 1761 0790 10E0      		ldi r17,hi8(ACTUATE_TASK)
 1762 0792 80E0      		ldi r24,lo8(gs(actuate_task))
 1763 0794 90E0      		ldi r25,hi8(gs(actuate_task))
 1764 0796 F801      		movw r30,r16
 1765 0798 9683      		std Z+6,r25
 1766 079a 8583      		std Z+5,r24
 730:main.c        ****   nrk_task_set_stk(&ACTUATE_TASK, actuate_task_stack, NRK_APP_STACKSIZE);
 1768               	.LM213:
 1769 079c 40E0      		ldi r20,0
 1770 079e 52E0      		ldi r21,lo8(2)
 1771 07a0 60E0      		ldi r22,lo8(actuate_task_stack)
 1772 07a2 70E0      		ldi r23,hi8(actuate_task_stack)
 1773 07a4 C801      		movw r24,r16
 1774 07a6 0E94 0000 		call nrk_task_set_stk
 731:main.c        ****   ACTUATE_TASK.prio = 4;
 1776               	.LM214:
 1777 07aa 84E0      		ldi r24,lo8(4)
 1778 07ac F801      		movw r30,r16
 1779 07ae 8087      		std Z+8,r24
 732:main.c        ****   ACTUATE_TASK.FirstActivation = TRUE;
 1781               	.LM215:
 1782 07b0 C783      		std Z+7,r28
 733:main.c        ****   ACTUATE_TASK.Type = BASIC_TASK;
 1784               	.LM216:
 1785 07b2 C187      		std Z+9,r28
 734:main.c        ****   ACTUATE_TASK.SchType = PREEMPTIVE;
 1787               	.LM217:
 1788 07b4 C287      		std Z+10,r28
 735:main.c        ****   ACTUATE_TASK.period.secs = 0;
 1790               	.LM218:
 1791 07b6 1386      		std Z+11,__zero_reg__
 1792 07b8 1486      		std Z+12,__zero_reg__
 1793 07ba 1586      		std Z+13,__zero_reg__
 1794 07bc 1686      		std Z+14,__zero_reg__
 736:main.c        ****   ACTUATE_TASK.period.nano_secs = 200*NANOS_PER_MS;
 1796               	.LM219:
 1797 07be 812C      		mov r8,__zero_reg__
 1798 07c0 22EC      		ldi r18,lo8(-62)
 1799 07c2 922E      		mov r9,r18
 1800 07c4 2BEE      		ldi r18,lo8(-21)
 1801 07c6 A22E      		mov r10,r18
 1802 07c8 2BE0      		ldi r18,lo8(11)
 1803 07ca B22E      		mov r11,r18
 1804 07cc 8786      		std Z+15,r8
 1805 07ce 908A      		std Z+16,r9
 1806 07d0 A18A      		std Z+17,r10
 1807 07d2 B28A      		std Z+18,r11
 737:main.c        ****   ACTUATE_TASK.cpu_reserve.secs = 0;
 1809               	.LM220:
 1810 07d4 138A      		std Z+19,__zero_reg__
 1811 07d6 148A      		std Z+20,__zero_reg__
 1812 07d8 158A      		std Z+21,__zero_reg__
 1813 07da 168A      		std Z+22,__zero_reg__
 738:main.c        ****   ACTUATE_TASK.cpu_reserve.nano_secs = 30*NANOS_PER_MS;
 1815               	.LM221:
 1816 07dc 80E8      		ldi r24,lo8(-128)
 1817 07de 93EC      		ldi r25,lo8(-61)
 1818 07e0 A9EC      		ldi r26,lo8(-55)
 1819 07e2 B1E0      		ldi r27,lo8(1)
 1820 07e4 878B      		std Z+23,r24
 1821 07e6 908F      		std Z+24,r25
 1822 07e8 A18F      		std Z+25,r26
 1823 07ea B28F      		std Z+26,r27
 739:main.c        ****   ACTUATE_TASK.offset.secs = 0;
 1825               	.LM222:
 1826 07ec 138E      		std Z+27,__zero_reg__
 1827 07ee 148E      		std Z+28,__zero_reg__
 1828 07f0 158E      		std Z+29,__zero_reg__
 1829 07f2 168E      		std Z+30,__zero_reg__
 740:main.c        ****   ACTUATE_TASK.offset.nano_secs = 0;
 1831               	.LM223:
 1832 07f4 178E      		std Z+31,__zero_reg__
 1833 07f6 10A2      		std Z+32,__zero_reg__
 1834 07f8 11A2      		std Z+33,__zero_reg__
 1835 07fa 12A2      		std Z+34,__zero_reg__
 741:main.c        **** 
 742:main.c        ****   // PRIORITY 3
 743:main.c        ****   TX_CMD_TASK.task = tx_cmd_task;
 1837               	.LM224:
 1838 07fc 00E0      		ldi r16,lo8(TX_CMD_TASK)
 1839 07fe 10E0      		ldi r17,hi8(TX_CMD_TASK)
 1840 0800 80E0      		ldi r24,lo8(gs(tx_cmd_task))
 1841 0802 90E0      		ldi r25,hi8(gs(tx_cmd_task))
 1842 0804 F801      		movw r30,r16
 1843 0806 9683      		std Z+6,r25
 1844 0808 8583      		std Z+5,r24
 744:main.c        ****   nrk_task_set_stk(&TX_CMD_TASK, tx_cmd_task_stack, NRK_APP_STACKSIZE);
 1846               	.LM225:
 1847 080a 40E0      		ldi r20,0
 1848 080c 52E0      		ldi r21,lo8(2)
 1849 080e 60E0      		ldi r22,lo8(tx_cmd_task_stack)
 1850 0810 70E0      		ldi r23,hi8(tx_cmd_task_stack)
 1851 0812 C801      		movw r24,r16
 1852 0814 0E94 0000 		call nrk_task_set_stk
 745:main.c        ****   TX_CMD_TASK.prio = 3;
 1854               	.LM226:
 1855 0818 83E0      		ldi r24,lo8(3)
 1856 081a F801      		movw r30,r16
 1857 081c 8087      		std Z+8,r24
 746:main.c        ****   TX_CMD_TASK.FirstActivation = TRUE;
 1859               	.LM227:
 1860 081e C783      		std Z+7,r28
 747:main.c        ****   TX_CMD_TASK.Type = BASIC_TASK;
 1862               	.LM228:
 1863 0820 C187      		std Z+9,r28
 748:main.c        ****   TX_CMD_TASK.SchType = PREEMPTIVE;
 1865               	.LM229:
 1866 0822 C287      		std Z+10,r28
 749:main.c        ****   TX_CMD_TASK.period.secs = 0;
 1868               	.LM230:
 1869 0824 1386      		std Z+11,__zero_reg__
 1870 0826 1486      		std Z+12,__zero_reg__
 1871 0828 1586      		std Z+13,__zero_reg__
 1872 082a 1686      		std Z+14,__zero_reg__
 750:main.c        ****   TX_CMD_TASK.period.nano_secs = 100*NANOS_PER_MS;
 1874               	.LM231:
 1875 082c C786      		std Z+15,r12
 1876 082e D08A      		std Z+16,r13
 1877 0830 E18A      		std Z+17,r14
 1878 0832 F28A      		std Z+18,r15
 751:main.c        ****   TX_CMD_TASK.cpu_reserve.secs = 0;
 1880               	.LM232:
 1881 0834 138A      		std Z+19,__zero_reg__
 1882 0836 148A      		std Z+20,__zero_reg__
 1883 0838 158A      		std Z+21,__zero_reg__
 1884 083a 168A      		std Z+22,__zero_reg__
 752:main.c        ****   TX_CMD_TASK.cpu_reserve.nano_secs = 20*NANOS_PER_MS;
 1886               	.LM233:
 1887 083c 478A      		std Z+23,r4
 1888 083e 508E      		std Z+24,r5
 1889 0840 618E      		std Z+25,r6
 1890 0842 728E      		std Z+26,r7
 753:main.c        ****   TX_CMD_TASK.offset.secs = 0;
 1892               	.LM234:
 1893 0844 138E      		std Z+27,__zero_reg__
 1894 0846 148E      		std Z+28,__zero_reg__
 1895 0848 158E      		std Z+29,__zero_reg__
 1896 084a 168E      		std Z+30,__zero_reg__
 754:main.c        ****   TX_CMD_TASK.offset.nano_secs = 0;
 1898               	.LM235:
 1899 084c 178E      		std Z+31,__zero_reg__
 1900 084e 10A2      		std Z+32,__zero_reg__
 1901 0850 11A2      		std Z+33,__zero_reg__
 1902 0852 12A2      		std Z+34,__zero_reg__
 755:main.c        **** 
 756:main.c        ****   // PRIORITY 2
 757:main.c        ****   SAMPLE_TASK.task = sample_task;
 1904               	.LM236:
 1905 0854 00E0      		ldi r16,lo8(SAMPLE_TASK)
 1906 0856 10E0      		ldi r17,hi8(SAMPLE_TASK)
 1907 0858 80E0      		ldi r24,lo8(gs(sample_task))
 1908 085a 90E0      		ldi r25,hi8(gs(sample_task))
 1909 085c F801      		movw r30,r16
 1910 085e 9683      		std Z+6,r25
 1911 0860 8583      		std Z+5,r24
 758:main.c        ****   nrk_task_set_stk(&SAMPLE_TASK, sample_task_stack, NRK_APP_STACKSIZE);
 1913               	.LM237:
 1914 0862 40E0      		ldi r20,0
 1915 0864 52E0      		ldi r21,lo8(2)
 1916 0866 60E0      		ldi r22,lo8(sample_task_stack)
 1917 0868 70E0      		ldi r23,hi8(sample_task_stack)
 1918 086a C801      		movw r24,r16
 1919 086c 0E94 0000 		call nrk_task_set_stk
 759:main.c        ****   SAMPLE_TASK.prio = 2;
 1921               	.LM238:
 1922 0870 82E0      		ldi r24,lo8(2)
 1923 0872 F801      		movw r30,r16
 1924 0874 8087      		std Z+8,r24
 760:main.c        ****   SAMPLE_TASK.FirstActivation = TRUE;
 1926               	.LM239:
 1927 0876 C783      		std Z+7,r28
 761:main.c        ****   SAMPLE_TASK.Type = BASIC_TASK;
 1929               	.LM240:
 1930 0878 C187      		std Z+9,r28
 762:main.c        ****   SAMPLE_TASK.SchType = PREEMPTIVE;
 1932               	.LM241:
 1933 087a C287      		std Z+10,r28
 763:main.c        ****   SAMPLE_TASK.period.secs = 1;
 1935               	.LM242:
 1936 087c 81E0      		ldi r24,lo8(1)
 1937 087e 90E0      		ldi r25,0
 1938 0880 A0E0      		ldi r26,0
 1939 0882 B0E0      		ldi r27,0
 1940 0884 8387      		std Z+11,r24
 1941 0886 9487      		std Z+12,r25
 1942 0888 A587      		std Z+13,r26
 1943 088a B687      		std Z+14,r27
 764:main.c        ****   SAMPLE_TASK.period.nano_secs = 0;
 1945               	.LM243:
 1946 088c 1786      		std Z+15,__zero_reg__
 1947 088e 108A      		std Z+16,__zero_reg__
 1948 0890 118A      		std Z+17,__zero_reg__
 1949 0892 128A      		std Z+18,__zero_reg__
 765:main.c        ****   SAMPLE_TASK.cpu_reserve.secs = 0;
 1951               	.LM244:
 1952 0894 138A      		std Z+19,__zero_reg__
 1953 0896 148A      		std Z+20,__zero_reg__
 1954 0898 158A      		std Z+21,__zero_reg__
 1955 089a 168A      		std Z+22,__zero_reg__
 766:main.c        ****   SAMPLE_TASK.cpu_reserve.nano_secs = 200*NANOS_PER_MS;
 1957               	.LM245:
 1958 089c 878A      		std Z+23,r8
 1959 089e 908E      		std Z+24,r9
 1960 08a0 A18E      		std Z+25,r10
 1961 08a2 B28E      		std Z+26,r11
 767:main.c        ****   SAMPLE_TASK.offset.secs = 0;
 1963               	.LM246:
 1964 08a4 138E      		std Z+27,__zero_reg__
 1965 08a6 148E      		std Z+28,__zero_reg__
 1966 08a8 158E      		std Z+29,__zero_reg__
 1967 08aa 168E      		std Z+30,__zero_reg__
 768:main.c        ****   SAMPLE_TASK.offset.nano_secs = 0;
 1969               	.LM247:
 1970 08ac 178E      		std Z+31,__zero_reg__
 1971 08ae 10A2      		std Z+32,__zero_reg__
 1972 08b0 11A2      		std Z+33,__zero_reg__
 1973 08b2 12A2      		std Z+34,__zero_reg__
 769:main.c        **** 
 770:main.c        ****   // PRIORITY 1
 771:main.c        ****   TX_DATA_TASK.task = tx_data_task;
 1975               	.LM248:
 1976 08b4 00E0      		ldi r16,lo8(TX_DATA_TASK)
 1977 08b6 10E0      		ldi r17,hi8(TX_DATA_TASK)
 1978 08b8 80E0      		ldi r24,lo8(gs(tx_data_task))
 1979 08ba 90E0      		ldi r25,hi8(gs(tx_data_task))
 1980 08bc F801      		movw r30,r16
 1981 08be 9683      		std Z+6,r25
 1982 08c0 8583      		std Z+5,r24
 772:main.c        ****   nrk_task_set_stk(&TX_DATA_TASK, tx_data_task_stack, NRK_APP_STACKSIZE);
 1984               	.LM249:
 1985 08c2 40E0      		ldi r20,0
 1986 08c4 52E0      		ldi r21,lo8(2)
 1987 08c6 60E0      		ldi r22,lo8(tx_data_task_stack)
 1988 08c8 70E0      		ldi r23,hi8(tx_data_task_stack)
 1989 08ca C801      		movw r24,r16
 1990 08cc 0E94 0000 		call nrk_task_set_stk
 773:main.c        ****   TX_DATA_TASK.prio = 1;
 1992               	.LM250:
 1993 08d0 F801      		movw r30,r16
 1994 08d2 C087      		std Z+8,r28
 774:main.c        ****   TX_DATA_TASK.FirstActivation = TRUE;
 1996               	.LM251:
 1997 08d4 C783      		std Z+7,r28
 775:main.c        ****   TX_DATA_TASK.Type = BASIC_TASK;
 1999               	.LM252:
 2000 08d6 C187      		std Z+9,r28
 776:main.c        ****   TX_DATA_TASK.SchType = PREEMPTIVE;
 2002               	.LM253:
 2003 08d8 C287      		std Z+10,r28
 777:main.c        ****   TX_DATA_TASK.period.secs = 5;
 2005               	.LM254:
 2006 08da 85E0      		ldi r24,lo8(5)
 2007 08dc 90E0      		ldi r25,0
 2008 08de A0E0      		ldi r26,0
 2009 08e0 B0E0      		ldi r27,0
 2010 08e2 8387      		std Z+11,r24
 2011 08e4 9487      		std Z+12,r25
 2012 08e6 A587      		std Z+13,r26
 2013 08e8 B687      		std Z+14,r27
 778:main.c        ****   TX_DATA_TASK.period.nano_secs = 0;
 2015               	.LM255:
 2016 08ea 1786      		std Z+15,__zero_reg__
 2017 08ec 108A      		std Z+16,__zero_reg__
 2018 08ee 118A      		std Z+17,__zero_reg__
 2019 08f0 128A      		std Z+18,__zero_reg__
 779:main.c        ****   TX_DATA_TASK.cpu_reserve.secs = 0;
 2021               	.LM256:
 2022 08f2 138A      		std Z+19,__zero_reg__
 2023 08f4 148A      		std Z+20,__zero_reg__
 2024 08f6 158A      		std Z+21,__zero_reg__
 2025 08f8 168A      		std Z+22,__zero_reg__
 780:main.c        ****   TX_DATA_TASK.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 2027               	.LM257:
 2028 08fa C78A      		std Z+23,r12
 2029 08fc D08E      		std Z+24,r13
 2030 08fe E18E      		std Z+25,r14
 2031 0900 F28E      		std Z+26,r15
 781:main.c        ****   TX_DATA_TASK.offset.secs = 0;
 2033               	.LM258:
 2034 0902 138E      		std Z+27,__zero_reg__
 2035 0904 148E      		std Z+28,__zero_reg__
 2036 0906 158E      		std Z+29,__zero_reg__
 2037 0908 168E      		std Z+30,__zero_reg__
 782:main.c        ****   TX_DATA_TASK.offset.nano_secs = 0;
 2039               	.LM259:
 2040 090a 178E      		std Z+31,__zero_reg__
 2041 090c 10A2      		std Z+32,__zero_reg__
 2042 090e 11A2      		std Z+33,__zero_reg__
 2043 0910 12A2      		std Z+34,__zero_reg__
 783:main.c        **** 
 784:main.c        ****   nrk_activate_task(&RX_MSG_TASK); 
 2045               	.LM260:
 2046 0912 80E0      		ldi r24,lo8(RX_MSG_TASK)
 2047 0914 90E0      		ldi r25,hi8(RX_MSG_TASK)
 2048 0916 0E94 0000 		call nrk_activate_task
 785:main.c        ****   nrk_activate_task(&TX_CMD_TASK);
 2050               	.LM261:
 2051 091a 80E0      		ldi r24,lo8(TX_CMD_TASK)
 2052 091c 90E0      		ldi r25,hi8(TX_CMD_TASK)
 2053 091e 0E94 0000 		call nrk_activate_task
 786:main.c        ****   nrk_activate_task(&TX_DATA_TASK);
 2055               	.LM262:
 2056 0922 C801      		movw r24,r16
 2057 0924 0E94 0000 		call nrk_activate_task
 787:main.c        ****   nrk_activate_task(&SAMPLE_TASK);
 2059               	.LM263:
 2060 0928 80E0      		ldi r24,lo8(SAMPLE_TASK)
 2061 092a 90E0      		ldi r25,hi8(SAMPLE_TASK)
 2062 092c 0E94 0000 		call nrk_activate_task
 788:main.c        ****   nrk_activate_task(&ACTUATE_TASK);
 2064               	.LM264:
 2065 0930 80E0      		ldi r24,lo8(ACTUATE_TASK)
 2066 0932 90E0      		ldi r25,hi8(ACTUATE_TASK)
 2067 0934 0E94 0000 		call nrk_activate_task
 789:main.c        **** 
 790:main.c        ****   nrk_kprintf(PSTR("Create done.\r\n"));
 2069               	.LM265:
 2070 0938 80E0      		ldi r24,lo8(__c.3911)
 2071 093a 90E0      		ldi r25,hi8(__c.3911)
 2072               	/* epilogue start */
 791:main.c        **** }
 2074               	.LM266:
 2075 093c CF91      		pop r28
 2076 093e 1F91      		pop r17
 2077 0940 0F91      		pop r16
 2078 0942 FF90      		pop r15
 2079 0944 EF90      		pop r14
 2080 0946 DF90      		pop r13
 2081 0948 CF90      		pop r12
 2082 094a BF90      		pop r11
 2083 094c AF90      		pop r10
 2084 094e 9F90      		pop r9
 2085 0950 8F90      		pop r8
 2086 0952 7F90      		pop r7
 2087 0954 6F90      		pop r6
 2088 0956 5F90      		pop r5
 2089 0958 4F90      		pop r4
 790:main.c        **** }
 2091               	.LM267:
 2092 095a 0C94 0000 		jmp nrk_kprintf
 2094               	.Lscope7:
 2096               		.stabd	78,0,0
 2097               		.section	.text.startup,"ax",@progbits
 2099               	.global	main
 2101               	main:
 2102               		.stabd	46,0,0
 103:main.c        ****   // setup ports/uart
 2104               	.LM268:
 2105               	.LFBB8:
 2106               	/* prologue: function */
 2107               	/* frame size = 0 */
 2108               	/* stack size = 0 */
 2109               	.L__stack_usage = 0
 105:main.c        ****   nrk_setup_uart (UART_BAUDRATE_115K2);
 2111               	.LM269:
 2112 0000 0E94 0000 		call nrk_setup_ports
 106:main.c        ****   nrk_init ();
 2114               	.LM270:
 2115 0004 80E1      		ldi r24,lo8(16)
 2116 0006 90E0      		ldi r25,0
 2117 0008 0E94 0000 		call nrk_setup_uart
 107:main.c        **** 
 2119               	.LM271:
 2120 000c 0E94 0000 		call nrk_init
 110:main.c        ****   nrk_led_clr(1);
 2122               	.LM272:
 2123 0010 80E0      		ldi r24,0
 2124 0012 90E0      		ldi r25,0
 2125 0014 0E94 0000 		call nrk_led_clr
 111:main.c        ****   nrk_led_clr(2);
 2127               	.LM273:
 2128 0018 81E0      		ldi r24,lo8(1)
 2129 001a 90E0      		ldi r25,0
 2130 001c 0E94 0000 		call nrk_led_clr
 112:main.c        ****   nrk_led_clr(3);
 2132               	.LM274:
 2133 0020 82E0      		ldi r24,lo8(2)
 2134 0022 90E0      		ldi r25,0
 2135 0024 0E94 0000 		call nrk_led_clr
 113:main.c        ****     
 2137               	.LM275:
 2138 0028 83E0      		ldi r24,lo8(3)
 2139 002a 90E0      		ldi r25,0
 2140 002c 0E94 0000 		call nrk_led_clr
 116:main.c        ****   blink_leds = 1;
 2142               	.LM276:
 2143 0030 81E0      		ldi r24,lo8(1)
 2144 0032 8093 0000 		sts print_incoming,r24
 117:main.c        **** 
 2146               	.LM277:
 2147 0036 8093 0000 		sts blink_leds,r24
 120:main.c        ****   act_queue_mux     = nrk_sem_create(1, 6);
 2149               	.LM278:
 2150 003a 66E0      		ldi r22,lo8(6)
 2151 003c 0E94 0000 		call nrk_sem_create
 2152 0040 9093 0000 		sts net_tx_buf_mux+1,r25
 2153 0044 8093 0000 		sts net_tx_buf_mux,r24
 121:main.c        ****   cmd_tx_queue_mux  = nrk_sem_create(1, 6);
 2155               	.LM279:
 2156 0048 66E0      		ldi r22,lo8(6)
 2157 004a 81E0      		ldi r24,lo8(1)
 2158 004c 0E94 0000 		call nrk_sem_create
 2159 0050 9093 0000 		sts act_queue_mux+1,r25
 2160 0054 8093 0000 		sts act_queue_mux,r24
 122:main.c        ****   data_tx_queue_mux = nrk_sem_create(1, 6);
 2162               	.LM280:
 2163 0058 66E0      		ldi r22,lo8(6)
 2164 005a 81E0      		ldi r24,lo8(1)
 2165 005c 0E94 0000 		call nrk_sem_create
 2166 0060 9093 0000 		sts cmd_tx_queue_mux+1,r25
 2167 0064 8093 0000 		sts cmd_tx_queue_mux,r24
 123:main.c        ****   hand_rx_queue_mux = nrk_sem_create(1, 6);
 2169               	.LM281:
 2170 0068 66E0      		ldi r22,lo8(6)
 2171 006a 81E0      		ldi r24,lo8(1)
 2172 006c 0E94 0000 		call nrk_sem_create
 2173 0070 9093 0000 		sts data_tx_queue_mux+1,r25
 2174 0074 8093 0000 		sts data_tx_queue_mux,r24
 124:main.c        ****   seq_num_mux       = nrk_sem_create(1, 6);
 2176               	.LM282:
 2177 0078 66E0      		ldi r22,lo8(6)
 2178 007a 81E0      		ldi r24,lo8(1)
 2179 007c 0E94 0000 		call nrk_sem_create
 2180 0080 9093 0000 		sts hand_rx_queue_mux+1,r25
 2181 0084 8093 0000 		sts hand_rx_queue_mux,r24
 125:main.c        **** 
 2183               	.LM283:
 2184 0088 66E0      		ldi r22,lo8(6)
 2185 008a 81E0      		ldi r24,lo8(1)
 2186 008c 0E94 0000 		call nrk_sem_create
 2187 0090 9093 0000 		sts seq_num_mux+1,r25
 2188 0094 8093 0000 		sts seq_num_mux,r24
 128:main.c        ****   temp_period = 35;
 2190               	.LM284:
 2191 0098 8EE1      		ldi r24,lo8(30)
 2192 009a 8093 0000 		sts pwr_period,r24
 129:main.c        ****   light_period = 40;
 2194               	.LM285:
 2195 009e 83E2      		ldi r24,lo8(35)
 2196 00a0 8093 0000 		sts temp_period,r24
 130:main.c        **** 
 2198               	.LM286:
 2199 00a4 88E2      		ldi r24,lo8(40)
 2200 00a6 8093 0000 		sts light_period,r24
 133:main.c        ****   packet_queue_init(&cmd_tx_queue);
 2202               	.LM287:
 2203 00aa 80E0      		ldi r24,lo8(act_queue)
 2204 00ac 90E0      		ldi r25,hi8(act_queue)
 2205 00ae 0E94 0000 		call packet_queue_init
 134:main.c        ****   packet_queue_init(&data_tx_queue);
 2207               	.LM288:
 2208 00b2 80E0      		ldi r24,lo8(cmd_tx_queue)
 2209 00b4 90E0      		ldi r25,hi8(cmd_tx_queue)
 2210 00b6 0E94 0000 		call packet_queue_init
 135:main.c        ****   packet_queue_init(&hand_rx_queue);
 2212               	.LM289:
 2213 00ba 80E0      		ldi r24,lo8(data_tx_queue)
 2214 00bc 90E0      		ldi r25,hi8(data_tx_queue)
 2215 00be 0E94 0000 		call packet_queue_init
 136:main.c        **** 
 2217               	.LM290:
 2218 00c2 80E0      		ldi r24,lo8(hand_rx_queue)
 2219 00c4 90E0      		ldi r25,hi8(hand_rx_queue)
 2220 00c6 0E94 0000 		call packet_queue_init
 139:main.c        ****   bmac_task_config();
 2222               	.LM291:
 2223 00ca 20E0      		ldi r18,0
 2224 00cc 30E0      		ldi r19,0
 2225 00ce A901      		movw r20,r18
 2226 00d0 60E0      		ldi r22,0
 2227 00d2 70E0      		ldi r23,0
 2228 00d4 CB01      		movw r24,r22
 2229 00d6 0E94 0000 		call nrk_time_set
 140:main.c        ****   nrk_create_taskset();
 2231               	.LM292:
 2232 00da 0E94 0000 		call bmac_task_config
 141:main.c        ****   bmac_init(13);
 2234               	.LM293:
 2235 00de 0E94 0000 		call nrk_create_taskset
 142:main.c        ****   nrk_start();
 2237               	.LM294:
 2238 00e2 8DE0      		ldi r24,lo8(13)
 2239 00e4 0E94 0000 		call bmac_init
 143:main.c        ****   return 0;
 2241               	.LM295:
 2242 00e8 0E94 0000 		call nrk_start
 145:main.c        **** 
 2244               	.LM296:
 2245 00ec 80E0      		ldi r24,0
 2246 00ee 90E0      		ldi r25,0
 2247 00f0 0895      		ret
 2249               	.Lscope8:
 2251               		.stabd	78,0,0
 2252               		.section	.progmem.data,"a",@progbits
 2255               	__c.3911:
 2256 0000 4372 6561 		.string	"Create done.\r\n"
 2256      7465 2064 
 2256      6F6E 652E 
 2256      0D0A 00
 2259               	__c.3873:
 2260 000f 5458 2064 		.string	"TX done signal error\r\n"
 2260      6F6E 6520 
 2260      7369 676E 
 2260      616C 2065 
 2260      7272 6F72 
 2263               	__c.3855:
 2264 0026 5458 2064 		.string	"TX done signal error\r\n"
 2264      6F6E 6520 
 2264      7369 676E 
 2264      616C 2065 
 2264      7272 6F72 
 2267               	__c.3833:
 2268 003d 7061 636B 		.string	"packet for me!\r\n"
 2268      6574 2066 
 2268      6F72 206D 
 2268      6521 0D0A 
 2268      00
 2271               	__c.3830:
 2272 004e 7278 2070 		.string	"rx pkt:\r\n"
 2272      6B74 3A0D 
 2272      0A00 
 2273               		.comm	blink_leds,1,1
 2274               		.comm	print_incoming,1,1
 2275               		.comm	seq_num_mux,2,1
 2276               	.global	seq_num
 2277               		.section .bss
 2280               	seq_num:
 2281 0000 0000      		.zero	2
 2282               		.comm	seq_pool,10,1
 2283               		.comm	sensor_pkt,6,1
 2284               		.comm	light_period,1,1
 2285               		.comm	temp_period,1,1
 2286               		.comm	pwr_period,1,1
 2287               		.comm	hand_rx_queue_mux,2,1
 2288               		.comm	hand_rx_queue,139,1
 2289               		.comm	data_tx_queue_mux,2,1
 2290               		.comm	data_tx_queue,139,1
 2291               		.comm	cmd_tx_queue_mux,2,1
 2292               		.comm	cmd_tx_queue,139,1
 2293               	.global	last_command
 2296               	last_command:
 2297 0002 0000      		.zero	2
 2298               		.comm	act_queue_mux,2,1
 2299               		.comm	act_queue,139,1
 2300               		.comm	net_tx_buf_mux,2,1
 2301               	.global	net_tx_index
 2304               	net_tx_index:
 2305 0004 00        		.zero	1
 2306               		.comm	net_tx_buf,116,1
 2307               		.comm	net_rx_buf,116,1
 2308               	.global	curr_state
 2309               		.data
 2312               	curr_state:
 2313 0000 01        		.byte	1
 2314               		.comm	actuate_task_stack,512,1
 2315               		.comm	sample_task_stack,512,1
 2316               		.comm	tx_data_task_stack,512,1
 2317               		.comm	tx_cmd_task_stack,512,1
 2318               		.comm	rx_msg_task_stack,512,1
 2319               		.comm	ACTUATE_TASK,35,1
 2320               		.comm	SAMPLE_TASK,35,1
 2321               		.comm	TX_DATA_TASK,35,1
 2322               		.comm	TX_CMD_TASK,35,1
 2323               		.comm	RX_MSG_TASK,35,1
 2324               		.comm	error_num,1,1
 2325               		.comm	error_task,1,1
 2326               		.comm	bmac_rfTxInfo,7,1
 2327               		.comm	bmac_rfRxInfo,12,1
 2328               		.comm	bmac_enable_signal,1,1
 2329               		.comm	bmac_tx_pkt_done_signal,1,1
 2330               		.comm	bmac_rx_pkt_signal,1,1
 2331               		.comm	nrk_kernel_stk_ptr,2,1
 2332               		.comm	nrk_idle_task_stk,512,1
 2333               		.comm	_nrk_signal_list,4,1
 2377               		.text
 2379               	.Letext0:
 2380               		.ident	"GCC: (GNU) 4.9.1"
 2381               	.global __do_copy_data
 2382               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:4      *ABS*:000000000000003f __SREG__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:356    .text:0000000000000000 rx_msg_task
                            *COM*:0000000000000074 net_rx_buf
                            *COM*:0000000000000001 blink_leds
                            *COM*:0000000000000001 print_incoming
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2271   .progmem.data:000000000000004e __c.3830
                            *COM*:000000000000000a seq_pool
                            *COM*:0000000000000002 data_tx_queue_mux
                            *COM*:000000000000008b data_tx_queue
                            *COM*:0000000000000002 hand_rx_queue_mux
                            *COM*:000000000000008b hand_rx_queue
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2296   .bss:0000000000000002 last_command
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2267   .progmem.data:000000000000003d __c.3833
                            *COM*:0000000000000002 act_queue_mux
                            *COM*:000000000000008b act_queue
                            *COM*:0000000000000002 cmd_tx_queue_mux
                            *COM*:000000000000008b cmd_tx_queue
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:657    .text:00000000000001be sample_task
                            *COM*:0000000000000006 sensor_pkt
                            *COM*:0000000000000001 pwr_period
                            *COM*:0000000000000001 temp_period
                            *COM*:0000000000000001 light_period
                            *COM*:0000000000000002 seq_num_mux
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2280   .bss:0000000000000000 seq_num
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:908    .text:000000000000030a actuate_task
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2312   .data:0000000000000000 curr_state
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:1145   .text:0000000000000438 clear_tx_buf
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2304   .bss:0000000000000004 net_tx_index
                            *COM*:0000000000000074 net_tx_buf
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:1189   .text:0000000000000454 tx_cmd_task
                            *COM*:0000000000000002 net_tx_buf_mux
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2263   .progmem.data:0000000000000026 __c.3855
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:1428   .text:00000000000005c8 tx_data_task
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2259   .progmem.data:000000000000000f __c.3873
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:1652   .text:00000000000006fa nrk_create_taskset
                            *COM*:0000000000000023 RX_MSG_TASK
                            *COM*:0000000000000200 rx_msg_task_stack
                            *COM*:0000000000000023 ACTUATE_TASK
                            *COM*:0000000000000200 actuate_task_stack
                            *COM*:0000000000000023 TX_CMD_TASK
                            *COM*:0000000000000200 tx_cmd_task_stack
                            *COM*:0000000000000023 SAMPLE_TASK
                            *COM*:0000000000000200 sample_task_stack
                            *COM*:0000000000000023 TX_DATA_TASK
                            *COM*:0000000000000200 tx_data_task_stack
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2255   .progmem.data:0000000000000000 __c.3911
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccEGCWOy.s:2101   .text.startup:0000000000000000 main
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000007 bmac_rfTxInfo
                            *COM*:000000000000000c bmac_rfRxInfo
                            *COM*:0000000000000001 bmac_enable_signal
                            *COM*:0000000000000001 bmac_tx_pkt_done_signal
                            *COM*:0000000000000001 bmac_rx_pkt_signal
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000200 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
bmac_rx_pkt_set_buffer
bmac_started
nrk_wait_until_next_period
nrk_led_set
nrk_led_clr
bmac_rx_pkt_ready
parse_msg
bmac_rx_pkt_get
bmac_rx_pkt_release
nrk_kprintf
print_packet
in_sequence_pool
add_to_sequence_pool
get_sequence_number
update_sequence_pool
nrk_sem_pend
push
nrk_sem_post
__udivmodqi4
pop
bmac_get_tx_done_signal
nrk_signal_register
assemble_packet
bmac_tx_pkt_nonblocking
nrk_event_wait
printf
nrk_task_set_stk
nrk_activate_task
nrk_setup_ports
nrk_setup_uart
nrk_init
nrk_sem_create
packet_queue_init
nrk_time_set
bmac_task_config
bmac_init
nrk_start
__do_copy_data
__do_clear_bss
