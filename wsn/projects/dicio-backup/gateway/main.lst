   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 352               	.global	rx_node_task
 354               	rx_node_task:
 355               		.stabd	46,0,0
   1:main.c        **** /**
   2:main.c        ****  * 18-748 Wireless Sensor Networks
   3:main.c        ****  * Spring 2016
   4:main.c        ****  * Lab 3: Multi-Hop Communication
   5:main.c        ****  * main.c (gateway)
   6:main.c        ****  * Kedar Amladi // kamladi. Daniel Santoro // ddsantor. Adam Selevan // aselevan.
   7:main.c        ****  */
   8:main.c        **** 
   9:main.c        **** // INCLUDES
  10:main.c        **** // standard nrk 
  11:main.c        **** #include <nrk.h>
  12:main.c        **** #include <nrk_events.h>
  13:main.c        **** #include <include.h>
  14:main.c        **** #include <ulib.h>
  15:main.c        **** #include <stdio.h>
  16:main.c        **** #include <stdlib.h>
  17:main.c        **** #include <avr/sleep.h>
  18:main.c        **** #include <hal.h>
  19:main.c        **** #include <bmac.h>
  20:main.c        **** #include <nrk_error.h>
  21:main.c        **** // this package
  22:main.c        **** #include <assembler.h>
  23:main.c        **** #include <light_pool.h>
  24:main.c        **** #include <neighbors.h>
  25:main.c        **** #include <packet_queue.h>
  26:main.c        **** #include <parser.h>
  27:main.c        **** #include <sequence_pool.h>
  28:main.c        **** #include <type_defs.h>
  29:main.c        **** 
  30:main.c        **** // DEFINES
  31:main.c        **** #define MAC_ADDR 1
  32:main.c        **** 
  33:main.c        **** 
  34:main.c        **** // FUNCTION DECLARATIONS
  35:main.c        **** uint8_t get_server_input(void);
  36:main.c        **** void clear_serv_buf();
  37:main.c        **** void rx_node_task(void);
  38:main.c        **** void rx_serv_task(void);
  39:main.c        **** void tx_cmd_task(void);
  40:main.c        **** void tx_node_task(void);
  41:main.c        **** void tx_serv_task(void);
  42:main.c        **** void nrk_create_taskset ();
  43:main.c        **** 
  44:main.c        **** // TASKS
  45:main.c        **** nrk_task_type RX_NODE_TASK;
  46:main.c        **** nrk_task_type RX_SERV_TASK;
  47:main.c        **** nrk_task_type TX_CMD_TASK;
  48:main.c        **** nrk_task_type TX_NODE_TASK;
  49:main.c        **** nrk_task_type TX_SERV_TASK;
  50:main.c        **** 
  51:main.c        **** // TASK STACKS
  52:main.c        **** NRK_STK rx_node_task_stack[NRK_APP_STACKSIZE];
  53:main.c        **** NRK_STK rx_serv_task_stack[NRK_APP_STACKSIZE];
  54:main.c        **** NRK_STK tx_cmd_task_stack[NRK_APP_STACKSIZE];
  55:main.c        **** NRK_STK tx_node_task_stack[NRK_APP_STACKSIZE];
  56:main.c        **** NRK_STK tx_serv_task_stack[NRK_APP_STACKSIZE];
  57:main.c        **** 
  58:main.c        **** // BUFFERS
  59:main.c        **** uint8_t net_rx_buf[RF_MAX_PAYLOAD_SIZE];
  60:main.c        **** uint8_t serv_rx_buf[RF_MAX_PAYLOAD_SIZE];
  61:main.c        **** uint8_t serv_rx_index = 0;
  62:main.c        **** uint8_t net_tx_buf[RF_MAX_PAYLOAD_SIZE];
  63:main.c        **** uint8_t net_tx_index = 0;
  64:main.c        **** nrk_sem_t* net_tx_buf_mux;
  65:main.c        **** uint8_t serv_tx_buf[RF_MAX_PAYLOAD_SIZE];
  66:main.c        **** 
  67:main.c        **** // QUEUES
  68:main.c        **** packet_queue cmd_tx_queue;
  69:main.c        **** nrk_sem_t* cmd_tx_queue_mux;
  70:main.c        **** packet_queue node_tx_queue;
  71:main.c        **** nrk_sem_t* node_tx_queue_mux;
  72:main.c        **** packet_queue serv_tx_queue;
  73:main.c        **** nrk_sem_t* serv_tx_queue_mux;
  74:main.c        **** packet_queue hand_rx_queue;
  75:main.c        **** nrk_sem_t* hand_rx_queue_mux;
  76:main.c        **** 
  77:main.c        **** // DRIVERS 
  78:main.c        **** void nrk_register_drivers();
  79:main.c        **** 
  80:main.c        **** // SEQUENCE POOLS/NUMBER
  81:main.c        **** sequence_pool_t seq_pool;
  82:main.c        **** uint16_t server_seq_num;
  83:main.c        **** uint16_t seq_num = 0;
  84:main.c        **** 
  85:main.c        **** // GLOBAL FLAG
  86:main.c        **** uint8_t print_incoming;
  87:main.c        **** uint8_t blink_leds;
  88:main.c        **** 
  89:main.c        **** int main () {
  90:main.c        ****   // setup ports/uart
  91:main.c        ****   nrk_setup_ports ();
  92:main.c        ****   nrk_setup_uart (UART_BAUDRATE_115K2);
  93:main.c        ****   nrk_init ();
  94:main.c        **** 
  95:main.c        ****   // clear all LEDs
  96:main.c        ****   nrk_led_clr(0);
  97:main.c        ****   nrk_led_clr(1);
  98:main.c        ****   nrk_led_clr(2);
  99:main.c        ****   nrk_led_clr(3);
 100:main.c        ****     
 101:main.c        ****   // print flag
 102:main.c        ****   print_incoming = 1;
 103:main.c        ****   blink_leds = 1;
 104:main.c        **** 
 105:main.c        ****   // mutexs
 106:main.c        ****   net_tx_buf_mux    = nrk_sem_create(1, 6);
 107:main.c        ****   cmd_tx_queue_mux  = nrk_sem_create(1, 6);
 108:main.c        ****   node_tx_queue_mux = nrk_sem_create(1, 6);
 109:main.c        ****   serv_tx_queue_mux = nrk_sem_create(1, 6);
 110:main.c        ****   hand_rx_queue_mux = nrk_sem_create(1, 6);
 111:main.c        **** 
 112:main.c        ****   // packet queues
 113:main.c        ****   packet_queue_init(&cmd_tx_queue);
 114:main.c        ****   packet_queue_init(&node_tx_queue);
 115:main.c        ****   packet_queue_init(&serv_tx_queue);
 116:main.c        ****   packet_queue_init(&hand_rx_queue);
 117:main.c        **** 
 118:main.c        ****   nrk_time_set (0, 0);
 119:main.c        ****   bmac_task_config();
 120:main.c        ****   nrk_create_taskset();
 121:main.c        ****   bmac_init (13);
 122:main.c        ****   nrk_start ();
 123:main.c        ****   return 0;
 124:main.c        **** }
 125:main.c        **** 
 126:main.c        **** /**
 127:main.c        ****  * get_server_input() - 
 128:main.c        ****  *  get UART data from server - end of message noted by a '\r'
 129:main.c        ****  */
 130:main.c        **** uint8_t get_server_input() {
 131:main.c        ****   uint8_t option;
 132:main.c        **** 
 133:main.c        ****   // loop until all bytes have been received
 134:main.c        ****   while(nrk_uart_data_ready(NRK_DEFAULT_UART)) {
 135:main.c        **** 
 136:main.c        ****     // get UART byte and add to buffer
 137:main.c        ****     option = getchar();
 138:main.c        **** 
 139:main.c        ****     // if there is room, add it to the buffer.
 140:main.c        ****     if(serv_rx_index < (RF_MAX_PAYLOAD_SIZE -1)) {
 141:main.c        ****       serv_rx_buf[serv_rx_index] = option;
 142:main.c        ****       serv_rx_index++;      
 143:main.c        ****     } 
 144:main.c        ****     // if there is not room, clear the buffer and then add the new byte.
 145:main.c        ****     else {
 146:main.c        ****       clear_serv_buf();
 147:main.c        ****       serv_rx_buf[serv_rx_index] = option;
 148:main.c        ****       serv_rx_index++;
 149:main.c        ****     }
 150:main.c        **** 
 151:main.c        ****     // print if appropriate
 152:main.c        ****     if(print_incoming == PRINT2TERM) {
 153:main.c        ****       printf("%c", option);
 154:main.c        ****     }
 155:main.c        **** 
 156:main.c        ****     // message has been completed
 157:main.c        ****     if(option == '\r') {
 158:main.c        ****       serv_rx_buf[serv_rx_index] = '\n';
 159:main.c        ****       serv_rx_index++;
 160:main.c        ****       if(print_incoming == PRINT2TERM) {
 161:main.c        ****         nrk_kprintf(PSTR("\n"));
 162:main.c        ****       }
 163:main.c        ****       return SERV_MSG_RECEIVED;    
 164:main.c        ****     }
 165:main.c        ****   }
 166:main.c        ****   return SERV_MSG_INCOMPLETE;
 167:main.c        **** }
 168:main.c        **** 
 169:main.c        **** /**
 170:main.c        ****  * clear_serv_buf() - 
 171:main.c        ****  *  clear the server buffer
 172:main.c        ****  */
 173:main.c        **** void clear_serv_buf() {
 174:main.c        ****   for(uint8_t i = 0; i < serv_rx_index; i++) {
 175:main.c        ****     serv_rx_buf[i] = '\0';
 176:main.c        ****   }
 177:main.c        ****   serv_rx_index = 0;
 178:main.c        **** }
 179:main.c        **** 
 180:main.c        **** void clear_tx_buf(){
 181:main.c        ****   for(uint8_t i = 0; i < net_tx_index; i++){
 182:main.c        ****     net_tx_buf[i] = 0;
 183:main.c        ****   }
 184:main.c        ****   net_tx_index = 0;
 185:main.c        **** }
 186:main.c        **** 
 187:main.c        **** /**
 188:main.c        ****  * rx_node_task() - 
 189:main.c        ****  *  receive messages from the network
 190:main.c        ****  */
 191:main.c        **** void rx_node_task() {
 357               	.LM0:
 358               	.LFBB1:
 359 0000 CF93      		push r28
 360 0002 DF93      		push r29
 361 0004 CDB7      		in r28,__SP_L__
 362 0006 DEB7      		in r29,__SP_H__
 363 0008 6397      		sbiw r28,19
 364 000a 0FB6      		in __tmp_reg__,__SREG__
 365 000c F894      		cli
 366 000e DEBF      		out __SP_H__,r29
 367 0010 0FBE      		out __SREG__,__tmp_reg__
 368 0012 CDBF      		out __SP_L__,r28
 369               	/* prologue: function */
 370               	/* frame size = 19 */
 371               	/* stack size = 21 */
 372               	.L__stack_usage = 21
 192:main.c        ****   // local variable instantiation
 193:main.c        ****   uint8_t LED_FLAG = 0;
 194:main.c        ****   packet rx_packet;
 195:main.c        ****   uint8_t len, rssi;
 196:main.c        ****   uint8_t *local_buf;
 197:main.c        ****   int8_t in_seq_pool;
 198:main.c        ****   uint16_t local_seq_num;
 199:main.c        ****   uint8_t new_node = NONE;
 200:main.c        **** 
 201:main.c        ****   // initialize network receive buffer
 202:main.c        ****   bmac_rx_pkt_set_buffer(net_rx_buf, RF_MAX_PAYLOAD_SIZE);
 374               	.LM1:
 375 0014 64E7      		ldi r22,lo8(116)
 376 0016 80E0      		ldi r24,lo8(net_rx_buf)
 377 0018 90E0      		ldi r25,hi8(net_rx_buf)
 378 001a 0E94 0000 		call bmac_rx_pkt_set_buffer
 379               	.L2:
 203:main.c        ****   
 204:main.c        ****   // Wait until bmac has started. This should be called by all tasks using bmac that do not call bm
 205:main.c        ****   while (!bmac_started ()){
 381               	.LM2:
 382 001e 0E94 0000 		call bmac_started
 383 0022 8111      		cpse r24,__zero_reg__
 384 0024 00C0      		rjmp .L22
 206:main.c        ****     nrk_wait_until_next_period ();
 386               	.LM3:
 387 0026 0E94 0000 		call nrk_wait_until_next_period
 388 002a 00C0      		rjmp .L2
 389               	.L22:
 390 002c 10E0      		ldi r17,0
 391               	.L15:
 207:main.c        ****   }
 208:main.c        ****   
 209:main.c        ****   // loop forever
 210:main.c        ****   while(1) {
 211:main.c        ****     // LED blinking - for debug
 212:main.c        ****     if(blink_leds == BLINKLEDS) {
 393               	.LM4:
 394 002e 8091 0000 		lds r24,blink_leds
 395 0032 8130      		cpi r24,lo8(1)
 396 0034 01F4      		brne .L4
 213:main.c        ****       LED_FLAG++;
 398               	.LM5:
 399 0036 810F      		add r24,r17
 214:main.c        ****       LED_FLAG%=2;
 215:main.c        ****       if(LED_FLAG == 0) {
 401               	.LM6:
 402 0038 182F      		mov r17,r24
 403 003a 1170      		andi r17,lo8(1)
 404 003c 80FD      		sbrc r24,0
 405 003e 00C0      		rjmp .L5
 216:main.c        ****         nrk_led_set(0);
 407               	.LM7:
 408 0040 80E0      		ldi r24,0
 409 0042 90E0      		ldi r25,0
 410 0044 0E94 0000 		call nrk_led_set
 411 0048 00C0      		rjmp .L4
 412               	.L5:
 217:main.c        ****       } else {
 218:main.c        ****         nrk_led_clr(0);
 414               	.LM8:
 415 004a 80E0      		ldi r24,0
 416 004c 90E0      		ldi r25,0
 417 004e 0E94 0000 		call nrk_led_clr
 418 0052 11E0      		ldi r17,lo8(1)
 419               	.L4:
 219:main.c        ****       }      
 220:main.c        ****     }
 221:main.c        **** 
 222:main.c        ****     // only execute if there is a packet available
 223:main.c        ****     if(bmac_rx_pkt_ready()) {
 421               	.LM9:
 422 0054 0E94 0000 		call bmac_rx_pkt_ready
 423 0058 8823      		tst r24
 424 005a 01F4      		brne .+2
 425 005c 00C0      		rjmp .L7
 224:main.c        ****       nrk_kprintf (PSTR ("pkt ready:\r\n"));
 427               	.LM10:
 428 005e 80E0      		ldi r24,lo8(__c.3839)
 429 0060 90E0      		ldi r25,hi8(__c.3839)
 430 0062 0E94 0000 		call nrk_kprintf
 225:main.c        ****       // get the packet, parse and release
 226:main.c        ****       parse_msg(&rx_packet, &net_rx_buf, len);
 432               	.LM11:
 433 0066 4B89      		ldd r20,Y+19
 434 0068 60E0      		ldi r22,lo8(net_rx_buf)
 435 006a 70E0      		ldi r23,hi8(net_rx_buf)
 436 006c CE01      		movw r24,r28
 437 006e 0196      		adiw r24,1
 438 0070 0E94 0000 		call parse_msg
 227:main.c        ****       local_buf = bmac_rx_pkt_get(&len, &rssi);
 440               	.LM12:
 441 0074 BE01      		movw r22,r28
 442 0076 6E5E      		subi r22,-18
 443 0078 7F4F      		sbci r23,-1
 444 007a CE01      		movw r24,r28
 445 007c 4396      		adiw r24,19
 446 007e 0E94 0000 		call bmac_rx_pkt_get
 228:main.c        ****       
 229:main.c        ****       // print incoming packet if appropriate
 230:main.c        ****       if(print_incoming == 1) {
 448               	.LM13:
 449 0082 8091 0000 		lds r24,print_incoming
 450 0086 8130      		cpi r24,lo8(1)
 451 0088 01F4      		brne .L8
 231:main.c        ****         nrk_kprintf (PSTR ("rx:\r\n"));
 453               	.LM14:
 454 008a 80E0      		ldi r24,lo8(__c.3841)
 455 008c 90E0      		ldi r25,hi8(__c.3841)
 456 008e 0E94 0000 		call nrk_kprintf
 232:main.c        ****         print_packet(&rx_packet);     
 458               	.LM15:
 459 0092 CE01      		movw r24,r28
 460 0094 0196      		adiw r24,1
 461 0096 0E94 0000 		call print_packet
 462               	.L8:
 233:main.c        ****       }
 234:main.c        **** 
 235:main.c        ****        bmac_rx_pkt_release ();  
 464               	.LM16:
 465 009a 0E94 0000 		call bmac_rx_pkt_release
 236:main.c        ****       
 237:main.c        ****       // only receive the message if it's not from the gateway
 238:main.c        ****       //  NOTE: this is required because the gateway will hear re-transmitted packets 
 239:main.c        ****       //    originally from itself.
 240:main.c        ****       if(rx_packet.source_id != MAC_ADDR) {
 467               	.LM17:
 468 009e 6981      		ldd r22,Y+1
 469 00a0 6130      		cpi r22,lo8(1)
 470 00a2 01F4      		brne .+2
 471 00a4 00C0      		rjmp .L7
 241:main.c        **** 
 242:main.c        ****         // check to see if this node is in the sequence pool, if not then add it
 243:main.c        ****         in_seq_pool = in_sequence_pool(&seq_pool, rx_packet.source_id);
 473               	.LM18:
 474 00a6 80E0      		ldi r24,lo8(seq_pool)
 475 00a8 90E0      		ldi r25,hi8(seq_pool)
 476 00aa 0E94 0000 		call in_sequence_pool
 244:main.c        ****         if(in_seq_pool == -1) {
 478               	.LM19:
 479 00ae 8F3F      		cpi r24,lo8(-1)
 480 00b0 01F4      		brne .L16
 245:main.c        ****           add_to_sequence_pool(&seq_pool, rx_packet.source_id, rx_packet.seq_num);
 482               	.LM20:
 483 00b2 4B81      		ldd r20,Y+3
 484 00b4 5C81      		ldd r21,Y+4
 485 00b6 6981      		ldd r22,Y+1
 486 00b8 80E0      		ldi r24,lo8(seq_pool)
 487 00ba 90E0      		ldi r25,hi8(seq_pool)
 488 00bc 0E94 0000 		call add_to_sequence_pool
 246:main.c        ****           new_node = NODE_FOUND;
 490               	.LM21:
 491 00c0 01E0      		ldi r16,lo8(1)
 492 00c2 00C0      		rjmp .L10
 493               	.L16:
 494 00c4 00E0      		ldi r16,0
 495               	.L10:
 247:main.c        ****         }
 248:main.c        ****       
 249:main.c        ****         // determine if we should act on this packet based on the sequence number
 250:main.c        ****         local_seq_num = get_sequence_number(&seq_pool, rx_packet.source_id);
 497               	.LM22:
 498 00c6 6981      		ldd r22,Y+1
 499 00c8 80E0      		ldi r24,lo8(seq_pool)
 500 00ca 90E0      		ldi r25,hi8(seq_pool)
 501 00cc 0E94 0000 		call get_sequence_number
 251:main.c        ****         if((rx_packet.seq_num > local_seq_num) || (new_node == NODE_FOUND)) {
 503               	.LM23:
 504 00d0 4B81      		ldd r20,Y+3
 505 00d2 5C81      		ldd r21,Y+4
 506 00d4 8417      		cp r24,r20
 507 00d6 9507      		cpc r25,r21
 508 00d8 00F0      		brlo .L11
 510               	.LM24:
 511 00da 0130      		cpi r16,lo8(1)
 512 00dc 01F4      		brne .L7
 513               	.L11:
 252:main.c        ****           
 253:main.c        ****           // update the sequence pool and reset the new_node flag
 254:main.c        ****           update_sequence_pool(&seq_pool, rx_packet.source_id, rx_packet.seq_num);
 515               	.LM25:
 516 00de 6981      		ldd r22,Y+1
 517 00e0 80E0      		ldi r24,lo8(seq_pool)
 518 00e2 90E0      		ldi r25,hi8(seq_pool)
 519 00e4 0E94 0000 		call update_sequence_pool
 255:main.c        ****           new_node = NONE;
 256:main.c        ****           
 257:main.c        ****           // put the message in the right queue based on the type
 258:main.c        ****           switch(rx_packet.type) {
 521               	.LM26:
 522 00e8 8A81      		ldd r24,Y+2
 523 00ea 8730      		cpi r24,lo8(7)
 524 00ec 01F0      		breq .L12
 525 00ee 8830      		cpi r24,lo8(8)
 526 00f0 01F0      		breq .L13
 527 00f2 8530      		cpi r24,lo8(5)
 528 00f4 01F4      		brne .L7
 529               	.L12:
 259:main.c        ****             // data received or command ack received -> forward to server
 260:main.c        ****             case MSG_DATA:
 261:main.c        ****             {
 262:main.c        ****               nrk_sem_pend(serv_tx_queue_mux);
 263:main.c        ****               push(&serv_tx_queue, &rx_packet);
 264:main.c        ****               nrk_sem_post(serv_tx_queue_mux);
 265:main.c        ****               break;
 266:main.c        ****             }
 267:main.c        ****             case MSG_CMDACK:
 268:main.c        ****             {
 269:main.c        ****               nrk_sem_pend(serv_tx_queue_mux);
 531               	.LM27:
 532 00f6 8091 0000 		lds r24,serv_tx_queue_mux
 533 00fa 9091 0000 		lds r25,serv_tx_queue_mux+1
 534 00fe 0E94 0000 		call nrk_sem_pend
 270:main.c        ****               push(&serv_tx_queue, &rx_packet);
 536               	.LM28:
 537 0102 BE01      		movw r22,r28
 538 0104 6F5F      		subi r22,-1
 539 0106 7F4F      		sbci r23,-1
 540 0108 80E0      		ldi r24,lo8(serv_tx_queue)
 541 010a 90E0      		ldi r25,hi8(serv_tx_queue)
 542 010c 0E94 0000 		call push
 271:main.c        ****               nrk_sem_post(serv_tx_queue_mux);
 544               	.LM29:
 545 0110 8091 0000 		lds r24,serv_tx_queue_mux
 546 0114 9091 0000 		lds r25,serv_tx_queue_mux+1
 547 0118 00C0      		rjmp .L20
 548               	.L13:
 272:main.c        ****               break;
 273:main.c        ****             }
 274:main.c        ****             // handshake message recieved -> deal with in handshake function
 275:main.c        ****             case MSG_HAND:
 276:main.c        ****               nrk_sem_pend(hand_rx_queue_mux);
 550               	.LM30:
 551 011a 8091 0000 		lds r24,hand_rx_queue_mux
 552 011e 9091 0000 		lds r25,hand_rx_queue_mux+1
 553 0122 0E94 0000 		call nrk_sem_pend
 277:main.c        ****               push(&hand_rx_queue, &rx_packet);
 555               	.LM31:
 556 0126 BE01      		movw r22,r28
 557 0128 6F5F      		subi r22,-1
 558 012a 7F4F      		sbci r23,-1
 559 012c 80E0      		ldi r24,lo8(hand_rx_queue)
 560 012e 90E0      		ldi r25,hi8(hand_rx_queue)
 561 0130 0E94 0000 		call push
 278:main.c        ****               nrk_sem_post(hand_rx_queue_mux);
 563               	.LM32:
 564 0134 8091 0000 		lds r24,hand_rx_queue_mux
 565 0138 9091 0000 		lds r25,hand_rx_queue_mux+1
 566               	.L20:
 567 013c 0E94 0000 		call nrk_sem_post
 568               	.L7:
 279:main.c        ****               break;
 280:main.c        ****             case MSG_NO_MESSAGE:
 281:main.c        ****               // do nothing. 
 282:main.c        ****               // NOTE: this is a valid case. If the message is not 'parsible' then it can be
 283:main.c        ****               //  given a 'NO_MESSAGE' type.
 284:main.c        ****               break;
 285:main.c        ****             case MSG_GATEWAY:
 286:main.c        ****             case MSG_CMD:
 287:main.c        ****               // do nothing...commands are sent by the gateway, so there is no
 288:main.c        ****               //  no need to pass it along.
 289:main.c        ****               break;
 290:main.c        ****             default:
 291:main.c        ****               // do nothing
 292:main.c        ****               // NOTICE: really this should never happen. Eventually, throw and error here.
 293:main.c        ****               break;
 294:main.c        ****           }
 295:main.c        ****         }        
 296:main.c        ****       }
 297:main.c        ****     }
 298:main.c        ****     nrk_wait_until_next_period();
 570               	.LM33:
 571 0140 0E94 0000 		call nrk_wait_until_next_period
 299:main.c        ****   }
 573               	.LM34:
 574 0144 00C0      		rjmp .L15
 582               	.Lscope1:
 584               		.stabd	78,0,0
 586               	.global	tx_cmd_task
 588               	tx_cmd_task:
 589               		.stabd	46,0,0
 300:main.c        **** }
 301:main.c        **** 
 302:main.c        **** /**
 303:main.c        ****  * rx_serv_task() - 
 304:main.c        ****  *  receive a message from the server
 305:main.c        ****  */
 306:main.c        **** void rx_serv_task() {
 307:main.c        ****   // local variable instantiation
 308:main.c        ****   uint8_t LED_FLAG = 0;
 309:main.c        ****   packet rx_packet;
 310:main.c        **** 
 311:main.c        ****   // get the UART signal and register it
 312:main.c        ****   nrk_sig_t uart_rx_signal = nrk_uart_rx_signal_get();
 313:main.c        ****   nrk_signal_register(uart_rx_signal);
 314:main.c        ****   
 315:main.c        ****   // loop forever
 316:main.c        ****   while (1) {
 317:main.c        ****     // LED blinking - for debug
 318:main.c        ****     if(blink_leds == BLINKLEDS) {
 319:main.c        ****       LED_FLAG++;
 320:main.c        ****       LED_FLAG%=2;
 321:main.c        ****       if(LED_FLAG == 0) {
 322:main.c        ****         nrk_led_set(1);
 323:main.c        ****       } else {
 324:main.c        ****         nrk_led_clr(1);
 325:main.c        ****       }      
 326:main.c        ****     }
 327:main.c        **** 
 328:main.c        ****     // only execute if a full server message has been received
 329:main.c        ****     if(get_server_input() == SERV_MSG_RECEIVED) {
 330:main.c        **** 
 331:main.c        ****       // print message if appropriate
 332:main.c        ****       if(print_incoming == 1) {
 333:main.c        ****         printf("%s", serv_rx_buf);     
 334:main.c        ****       }
 335:main.c        **** 
 336:main.c        ****       // parse message
 337:main.c        ****       parse_serv_msg(&rx_packet, &serv_rx_buf, serv_rx_index);
 338:main.c        ****       clear_serv_buf();
 339:main.c        **** 
 340:main.c        ****       // check sequence number to determine if the packet should be received
 341:main.c        ****       // NOTE: This probably is unnecessary because the likelihood of an earlier
 342:main.c        ****       //  message being delivered serially is very slim. However, one can imagine
 343:main.c        ****       //  that if these were actual network messages that a delay would be much more
 344:main.c        ****       //  probable. Thus, in the spirit of correctness and completeness, we will
 345:main.c        ****       //  keep track of these sequence numbers.
 346:main.c        ****       if(rx_packet.seq_num > server_seq_num) {
 347:main.c        **** 
 348:main.c        ****         // update local sequence number
 349:main.c        ****         server_seq_num = rx_packet.seq_num;
 350:main.c        **** 
 351:main.c        **** 
 352:main.c        ****         switch(rx_packet.type) {
 353:main.c        ****           // if a command
 354:main.c        ****           case MSG_CMD:
 355:main.c        ****           {
 356:main.c        ****             //nrk_kprintf (PSTR ("push to Q\r\n")); // for debugging
 357:main.c        ****             nrk_sem_pend(cmd_tx_queue_mux);
 358:main.c        ****             push(&cmd_tx_queue, &rx_packet);
 359:main.c        ****             nrk_sem_post(cmd_tx_queue_mux);
 360:main.c        ****             break;
 361:main.c        ****           }
 362:main.c        ****           case MSG_NO_MESSAGE:
 363:main.c        ****             // do nothing. 
 364:main.c        ****             // NOTE: this is a valid case. If the message is not 'parsible' then it can be
 365:main.c        ****             //  given a 'NO_MESSAGE' type.
 366:main.c        ****             break;
 367:main.c        ****           case MSG_GATEWAY:
 368:main.c        ****           case MSG_DATA:
 369:main.c        ****           case MSG_CMDACK:
 370:main.c        ****           case MSG_HAND: 
 371:main.c        ****             // do nothing
 372:main.c        ****             // NOTICE: really, this should never happend. Eventually, throw an error here.
 373:main.c        ****             break;  
 374:main.c        ****           default:
 375:main.c        ****             // do nothing
 376:main.c        ****             // NOTICE: really this should never happen. Eventually, throw an error here.
 377:main.c        ****             break;
 378:main.c        ****         }
 379:main.c        ****       }
 380:main.c        ****     }
 381:main.c        ****     nrk_wait_until_next_period();
 382:main.c        ****   }
 383:main.c        **** }
 384:main.c        **** 
 385:main.c        **** /**
 386:main.c        ****  * tx_cmd_task() -
 387:main.c        ****  *  send all commands out to the network.
 388:main.c        ****  */
 389:main.c        **** void tx_cmd_task() {
 591               	.LM35:
 592               	.LFBB2:
 593 0146 CF93      		push r28
 594 0148 DF93      		push r29
 595 014a CDB7      		in r28,__SP_L__
 596 014c DEB7      		in r29,__SP_H__
 597 014e 6197      		sbiw r28,17
 598 0150 0FB6      		in __tmp_reg__,__SREG__
 599 0152 F894      		cli
 600 0154 DEBF      		out __SP_H__,r29
 601 0156 0FBE      		out __SREG__,__tmp_reg__
 602 0158 CDBF      		out __SP_L__,r28
 603               	/* prologue: function */
 604               	/* frame size = 17 */
 605               	/* stack size = 19 */
 606               	.L__stack_usage = 19
 607               	.L24:
 390:main.c        ****   // local variable instantiation
 391:main.c        ****   uint8_t LED_FLAG = 0;
 392:main.c        ****   uint16_t val;
 393:main.c        ****   nrk_sig_t tx_done_signal;
 394:main.c        ****   nrk_sig_mask_t ret;
 395:main.c        ****   packet tx_packet;
 396:main.c        ****   uint8_t tx_cmd_queue_size;
 397:main.c        **** 
 398:main.c        ****   // Wait until bmac has started. This should be called by all tasks 
 399:main.c        ****   //  using bmac that do not call bmac_init().
 400:main.c        ****   while(!bmac_started()) {
 609               	.LM36:
 610 015a 0E94 0000 		call bmac_started
 611 015e 8111      		cpse r24,__zero_reg__
 612 0160 00C0      		rjmp .L40
 401:main.c        ****     nrk_wait_until_next_period();
 614               	.LM37:
 615 0162 0E94 0000 		call nrk_wait_until_next_period
 616 0166 00C0      		rjmp .L24
 617               	.L40:
 402:main.c        ****   }
 403:main.c        **** 
 404:main.c        ****   // Get and register the tx_done_signal to perform non-blocking transmits
 405:main.c        ****   tx_done_signal = bmac_get_tx_done_signal();
 619               	.LM38:
 620 0168 0E94 0000 		call bmac_get_tx_done_signal
 621 016c 182F      		mov r17,r24
 406:main.c        ****   nrk_signal_register(tx_done_signal);
 623               	.LM39:
 624 016e 0E94 0000 		call nrk_signal_register
 625               	.LBB3:
 407:main.c        **** 
 408:main.c        ****   // loop forever
 409:main.c        ****   while(1){
 410:main.c        ****     // LED blinking - for debug
 411:main.c        ****     if(blink_leds == BLINKLEDS) {
 412:main.c        ****       LED_FLAG++;
 413:main.c        ****       LED_FLAG%=2;
 414:main.c        ****       if(LED_FLAG == 0) {
 415:main.c        ****         nrk_led_set(2);
 416:main.c        ****       } else {
 417:main.c        ****         nrk_led_clr(2);
 418:main.c        ****       }      
 419:main.c        ****     }
 420:main.c        **** 
 421:main.c        ****     // atomically get the queue size
 422:main.c        ****     nrk_sem_pend(cmd_tx_queue_mux);
 423:main.c        ****       tx_cmd_queue_size = cmd_tx_queue.size;
 424:main.c        ****     nrk_sem_post(cmd_tx_queue_mux);
 425:main.c        **** 
 426:main.c        ****     /**
 427:main.c        ****      * loop on queue size received above, and no more.
 428:main.c        ****      *  NOTE: during this loop the queue can be added to. If, for instance,
 429:main.c        ****      *    a "while(cmd_tx_queue.size > 0)" was used a few bad things could happen
 430:main.c        ****      *      (1) a mutex would be required around the entire loop - BAD IDEA
 431:main.c        ****      *      (2) the queue could be added to while this loop is running, thus
 432:main.c        ****      *        making the loop unbounded - BAD IDEA
 433:main.c        ****      *      (3) the size the queue read and the actual size of the queue could be 
 434:main.c        ****      *        incorrect due to preemtion - BAD IDEA
 435:main.c        ****      *    Doing it this way bounds this loop to the maximum size of the queue
 436:main.c        ****      *    at any given time, regardless of whether or not the queue has been 
 437:main.c        ****      *    added to by another task.
 438:main.c        ****      */
 439:main.c        ****     for(uint8_t i = 0; i < tx_cmd_queue_size; i++) {
 440:main.c        ****       // get a packet out of the queue.
 441:main.c        ****       nrk_sem_pend(cmd_tx_queue_mux);
 442:main.c        ****       pop(&cmd_tx_queue, &tx_packet);
 443:main.c        ****       nrk_sem_post(cmd_tx_queue_mux);
 444:main.c        **** 
 445:main.c        ****       // NOTE: a mutex is required around the network transmit buffer because 
 446:main.c        ****       //  tx_cmd_task() also uses it.
 447:main.c        ****       nrk_sem_pend(net_tx_buf_mux);
 448:main.c        ****       net_tx_index = assemble_packet(&net_tx_buf, &tx_packet);
 449:main.c        ****       if(print_incoming == 1){
 450:main.c        ****        nrk_kprintf (PSTR ("asm pkt:\r\n"));
 451:main.c        ****       }
 452:main.c        **** 
 453:main.c        ****       // send the packet
 454:main.c        ****       val = bmac_tx_pkt_nonblocking(net_tx_buf, net_tx_index);
 455:main.c        ****       ret = nrk_event_wait (SIG(tx_done_signal));
 627               	.LM40:
 628 0172 C12C      		mov r12,__zero_reg__
 629 0174 D12C      		mov r13,__zero_reg__
 630 0176 7601      		movw r14,r12
 631 0178 C394      		inc r12
 632 017a 00C0      		rjmp 2f
 633               		1:
 634 017c CC0C      		lsl r12
 635 017e DD1C      		rol r13
 636 0180 EE1C      		rol r14
 637 0182 FF1C      		rol r15
 638               		2:
 639 0184 1A95      		dec r17
 640 0186 02F4      		brpl 1b
 456:main.c        ****       
 457:main.c        ****       // Just check to be sure signal is okay
 458:main.c        ****       if(ret & (SIG(tx_done_signal) == 0)) {
 642               	.LM41:
 643 0188 812C      		mov r8,__zero_reg__
 644 018a 912C      		mov r9,__zero_reg__
 645 018c 5401      		movw r10,r8
 646 018e 8394      		inc r8
 647 0190 C114      		cp r12,__zero_reg__
 648 0192 D104      		cpc r13,__zero_reg__
 649 0194 E104      		cpc r14,__zero_reg__
 650 0196 F104      		cpc r15,__zero_reg__
 651 0198 01F0      		breq .L26
 652 019a 812C      		mov r8,__zero_reg__
 653 019c 912C      		mov r9,__zero_reg__
 654 019e 5401      		movw r10,r8
 655               	.L26:
 656               	.LBE3:
 391:main.c        ****   uint16_t val;
 658               	.LM42:
 659 01a0 10E0      		ldi r17,0
 660               	.L33:
 411:main.c        ****       LED_FLAG++;
 662               	.LM43:
 663 01a2 8091 0000 		lds r24,blink_leds
 664 01a6 8130      		cpi r24,lo8(1)
 665 01a8 01F4      		brne .L27
 412:main.c        ****       LED_FLAG%=2;
 667               	.LM44:
 668 01aa 810F      		add r24,r17
 414:main.c        ****         nrk_led_set(2);
 670               	.LM45:
 671 01ac 182F      		mov r17,r24
 672 01ae 1170      		andi r17,lo8(1)
 673 01b0 80FD      		sbrc r24,0
 674 01b2 00C0      		rjmp .L28
 415:main.c        ****       } else {
 676               	.LM46:
 677 01b4 82E0      		ldi r24,lo8(2)
 678 01b6 90E0      		ldi r25,0
 679 01b8 0E94 0000 		call nrk_led_set
 680 01bc 00C0      		rjmp .L27
 681               	.L28:
 417:main.c        ****       }      
 683               	.LM47:
 684 01be 82E0      		ldi r24,lo8(2)
 685 01c0 90E0      		ldi r25,0
 686 01c2 0E94 0000 		call nrk_led_clr
 687 01c6 11E0      		ldi r17,lo8(1)
 688               	.L27:
 422:main.c        ****       tx_cmd_queue_size = cmd_tx_queue.size;
 690               	.LM48:
 691 01c8 8091 0000 		lds r24,cmd_tx_queue_mux
 692 01cc 9091 0000 		lds r25,cmd_tx_queue_mux+1
 693 01d0 0E94 0000 		call nrk_sem_pend
 423:main.c        ****     nrk_sem_post(cmd_tx_queue_mux);
 695               	.LM49:
 696 01d4 7090 0000 		lds r7,cmd_tx_queue+138
 424:main.c        **** 
 698               	.LM50:
 699 01d8 8091 0000 		lds r24,cmd_tx_queue_mux
 700 01dc 9091 0000 		lds r25,cmd_tx_queue_mux+1
 701 01e0 0E94 0000 		call nrk_sem_post
 702               	.LBB4:
 439:main.c        ****       // get a packet out of the queue.
 704               	.LM51:
 705 01e4 00E0      		ldi r16,0
 706               	.L29:
 439:main.c        ****       // get a packet out of the queue.
 708               	.LM52:
 709 01e6 0715      		cp r16,r7
 710 01e8 01F4      		brne .+2
 711 01ea 00C0      		rjmp .L41
 441:main.c        ****       pop(&cmd_tx_queue, &tx_packet);
 713               	.LM53:
 714 01ec 8091 0000 		lds r24,cmd_tx_queue_mux
 715 01f0 9091 0000 		lds r25,cmd_tx_queue_mux+1
 716 01f4 0E94 0000 		call nrk_sem_pend
 442:main.c        ****       nrk_sem_post(cmd_tx_queue_mux);
 718               	.LM54:
 719 01f8 BE01      		movw r22,r28
 720 01fa 6F5F      		subi r22,-1
 721 01fc 7F4F      		sbci r23,-1
 722 01fe 80E0      		ldi r24,lo8(cmd_tx_queue)
 723 0200 90E0      		ldi r25,hi8(cmd_tx_queue)
 724 0202 0E94 0000 		call pop
 443:main.c        **** 
 726               	.LM55:
 727 0206 8091 0000 		lds r24,cmd_tx_queue_mux
 728 020a 9091 0000 		lds r25,cmd_tx_queue_mux+1
 729 020e 0E94 0000 		call nrk_sem_post
 447:main.c        ****       net_tx_index = assemble_packet(&net_tx_buf, &tx_packet);
 731               	.LM56:
 732 0212 8091 0000 		lds r24,net_tx_buf_mux
 733 0216 9091 0000 		lds r25,net_tx_buf_mux+1
 734 021a 0E94 0000 		call nrk_sem_pend
 448:main.c        ****       if(print_incoming == 1){
 736               	.LM57:
 737 021e BE01      		movw r22,r28
 738 0220 6F5F      		subi r22,-1
 739 0222 7F4F      		sbci r23,-1
 740 0224 80E0      		ldi r24,lo8(net_tx_buf)
 741 0226 90E0      		ldi r25,hi8(net_tx_buf)
 742 0228 0E94 0000 		call assemble_packet
 743 022c 8093 0000 		sts net_tx_index,r24
 449:main.c        ****        nrk_kprintf (PSTR ("asm pkt:\r\n"));
 745               	.LM58:
 746 0230 8091 0000 		lds r24,print_incoming
 747 0234 8130      		cpi r24,lo8(1)
 748 0236 01F4      		brne .L30
 450:main.c        ****       }
 750               	.LM59:
 751 0238 80E0      		ldi r24,lo8(__c.3878)
 752 023a 90E0      		ldi r25,hi8(__c.3878)
 753 023c 0E94 0000 		call nrk_kprintf
 754               	.L30:
 454:main.c        ****       ret = nrk_event_wait (SIG(tx_done_signal));
 756               	.LM60:
 757 0240 6091 0000 		lds r22,net_tx_index
 758 0244 80E0      		ldi r24,lo8(net_tx_buf)
 759 0246 90E0      		ldi r25,hi8(net_tx_buf)
 760 0248 0E94 0000 		call bmac_tx_pkt_nonblocking
 455:main.c        ****       
 762               	.LM61:
 763 024c C701      		movw r24,r14
 764 024e B601      		movw r22,r12
 765 0250 0E94 0000 		call nrk_event_wait
 767               	.LM62:
 768 0254 DC01      		movw r26,r24
 769 0256 CB01      		movw r24,r22
 770 0258 8821      		and r24,r8
 771 025a 9921      		and r25,r9
 772 025c AA21      		and r26,r10
 773 025e BB21      		and r27,r11
 774 0260 892B      		or r24,r25
 775 0262 8A2B      		or r24,r26
 776 0264 8B2B      		or r24,r27
 777 0266 01F0      		breq .L31
 459:main.c        ****         nrk_kprintf (PSTR ("TX done signal error\r\n"));
 779               	.LM63:
 780 0268 80E0      		ldi r24,lo8(__c.3880)
 781 026a 90E0      		ldi r25,hi8(__c.3880)
 782 026c 0E94 0000 		call nrk_kprintf
 783               	.L31:
 460:main.c        ****       }
 461:main.c        ****       nrk_sem_post(net_tx_buf_mux);     
 785               	.LM64:
 786 0270 8091 0000 		lds r24,net_tx_buf_mux
 787 0274 9091 0000 		lds r25,net_tx_buf_mux+1
 788 0278 0E94 0000 		call nrk_sem_post
 439:main.c        ****       // get a packet out of the queue.
 790               	.LM65:
 791 027c 0F5F      		subi r16,lo8(-(1))
 792 027e 00C0      		rjmp .L29
 793               	.L41:
 794               	.LBE4:
 462:main.c        ****     }
 463:main.c        ****     nrk_wait_until_next_period();
 796               	.LM66:
 797 0280 0E94 0000 		call nrk_wait_until_next_period
 464:main.c        ****   }
 799               	.LM67:
 800 0284 00C0      		rjmp .L33
 814               	.Lscope2:
 816               		.stabd	78,0,0
 818               	.global	tx_node_task
 820               	tx_node_task:
 821               		.stabd	46,0,0
 465:main.c        **** }
 466:main.c        **** 
 467:main.c        **** /**
 468:main.c        ****  * tx_node_task() -
 469:main.c        ****  *  send standard messages out to the network (i.e. handshake messages, etc.)
 470:main.c        ****  */
 471:main.c        **** void tx_node_task() {
 823               	.LM68:
 824               	.LFBB3:
 825 0286 CF93      		push r28
 826 0288 DF93      		push r29
 827 028a CDB7      		in r28,__SP_L__
 828 028c DEB7      		in r29,__SP_H__
 829 028e 6197      		sbiw r28,17
 830 0290 0FB6      		in __tmp_reg__,__SREG__
 831 0292 F894      		cli
 832 0294 DEBF      		out __SP_H__,r29
 833 0296 0FBE      		out __SREG__,__tmp_reg__
 834 0298 CDBF      		out __SP_L__,r28
 835               	/* prologue: function */
 836               	/* frame size = 17 */
 837               	/* stack size = 19 */
 838               	.L__stack_usage = 19
 839               	.L43:
 472:main.c        ****   // local variable initialization
 473:main.c        ****   uint8_t LED_FLAG = 0;
 474:main.c        ****   uint16_t val;
 475:main.c        ****   nrk_sig_t tx_done_signal;
 476:main.c        ****   nrk_sig_mask_t ret;
 477:main.c        ****   packet tx_packet;
 478:main.c        ****   uint8_t tx_node_queue_size;
 479:main.c        ****   
 480:main.c        ****   // Wait until bmac has started. This should be called by all tasks 
 481:main.c        ****   //  using bmac that do not call bmac_init().
 482:main.c        ****   while(!bmac_started ()) {
 841               	.LM69:
 842 029a 0E94 0000 		call bmac_started
 843 029e 8111      		cpse r24,__zero_reg__
 844 02a0 00C0      		rjmp .L58
 483:main.c        ****     nrk_wait_until_next_period ();
 846               	.LM70:
 847 02a2 0E94 0000 		call nrk_wait_until_next_period
 848 02a6 00C0      		rjmp .L43
 849               	.L58:
 484:main.c        ****   }
 485:main.c        **** 
 486:main.c        ****   // Get and register the tx_done_signal to perform non-blocking transmits
 487:main.c        ****   tx_done_signal = bmac_get_tx_done_signal();
 851               	.LM71:
 852 02a8 0E94 0000 		call bmac_get_tx_done_signal
 853 02ac 182F      		mov r17,r24
 488:main.c        ****   nrk_signal_register(tx_done_signal);
 855               	.LM72:
 856 02ae 0E94 0000 		call nrk_signal_register
 857               	.LBB5:
 489:main.c        ****   
 490:main.c        ****   while(1) {
 491:main.c        ****     // LED blinking - for debug
 492:main.c        ****     if(blink_leds == BLINKLEDS) {
 493:main.c        ****       LED_FLAG++;
 494:main.c        ****       LED_FLAG%=2;
 495:main.c        ****       if(LED_FLAG == 0) {
 496:main.c        ****         nrk_led_set(3);
 497:main.c        ****       } else {
 498:main.c        ****         nrk_led_clr(3);
 499:main.c        ****       }      
 500:main.c        ****     }
 501:main.c        ****  
 502:main.c        ****     // atomically get the queue size
 503:main.c        ****     nrk_sem_pend(node_tx_queue_mux);
 504:main.c        ****       tx_node_queue_size = node_tx_queue.size;
 505:main.c        ****     nrk_sem_post(node_tx_queue_mux);
 506:main.c        **** 
 507:main.c        ****     /**
 508:main.c        ****      * loop on queue size received above, and no more.
 509:main.c        ****      *  NOTE: during this loop the queue can be added to. If, for instance,
 510:main.c        ****      *    a "while(node_tx_queue.size > 0)" was used a few bad things could happen
 511:main.c        ****      *      (1) a mutex would be required around the entire loop - BAD IDEA
 512:main.c        ****      *      (2) the queue could be added to while this loop is running, thus
 513:main.c        ****      *        making the loop unbounded - BAD IDEA
 514:main.c        ****      *      (3) the size the queue read and the actual size of the queue could be 
 515:main.c        ****      *        incorrect due to preemtion - BAD IDEA
 516:main.c        ****      *    Doing it this way bounds this loop to the maximum size of the queue
 517:main.c        ****      *    at any given time, regardless of whether or not the queue has been 
 518:main.c        ****      *    added to by another task.
 519:main.c        ****      */
 520:main.c        ****     for(uint8_t i = 0; i < tx_node_queue_size; i++) {
 521:main.c        ****       // get a packet out of the queue.
 522:main.c        ****       nrk_sem_pend(node_tx_queue_mux);
 523:main.c        ****       pop(&node_tx_queue, &tx_packet);
 524:main.c        ****       nrk_sem_post(node_tx_queue_mux);
 525:main.c        **** 
 526:main.c        ****       // NOTE: a mutex is required around the network transmit buffer because 
 527:main.c        ****       //  tx_cmd_task() also uses it.
 528:main.c        ****       nrk_sem_pend(net_tx_buf_mux);
 529:main.c        ****       assemble_packet(&net_tx_buf, &tx_packet);
 530:main.c        ****       // send the packet
 531:main.c        ****       val = bmac_tx_pkt_nonblocking(net_tx_buf, strlen(net_tx_buf));
 532:main.c        ****       ret = nrk_event_wait (SIG(tx_done_signal));
 859               	.LM73:
 860 02b2 C12C      		mov r12,__zero_reg__
 861 02b4 D12C      		mov r13,__zero_reg__
 862 02b6 7601      		movw r14,r12
 863 02b8 C394      		inc r12
 864 02ba 00C0      		rjmp 2f
 865               		1:
 866 02bc CC0C      		lsl r12
 867 02be DD1C      		rol r13
 868 02c0 EE1C      		rol r14
 869 02c2 FF1C      		rol r15
 870               		2:
 871 02c4 1A95      		dec r17
 872 02c6 02F4      		brpl 1b
 533:main.c        ****       
 534:main.c        ****       // Just check to be sure signal is okay
 535:main.c        ****       if(ret & (SIG(tx_done_signal) == 0)) {
 874               	.LM74:
 875 02c8 812C      		mov r8,__zero_reg__
 876 02ca 912C      		mov r9,__zero_reg__
 877 02cc 5401      		movw r10,r8
 878 02ce 8394      		inc r8
 879 02d0 C114      		cp r12,__zero_reg__
 880 02d2 D104      		cpc r13,__zero_reg__
 881 02d4 E104      		cpc r14,__zero_reg__
 882 02d6 F104      		cpc r15,__zero_reg__
 883 02d8 01F0      		breq .L45
 884 02da 812C      		mov r8,__zero_reg__
 885 02dc 912C      		mov r9,__zero_reg__
 886 02de 5401      		movw r10,r8
 887               	.L45:
 888               	.LBE5:
 473:main.c        ****   uint16_t val;
 890               	.LM75:
 891 02e0 10E0      		ldi r17,0
 892               	.L51:
 492:main.c        ****       LED_FLAG++;
 894               	.LM76:
 895 02e2 8091 0000 		lds r24,blink_leds
 896 02e6 8130      		cpi r24,lo8(1)
 897 02e8 01F4      		brne .L46
 493:main.c        ****       LED_FLAG%=2;
 899               	.LM77:
 900 02ea 810F      		add r24,r17
 495:main.c        ****         nrk_led_set(3);
 902               	.LM78:
 903 02ec 182F      		mov r17,r24
 904 02ee 1170      		andi r17,lo8(1)
 905 02f0 80FD      		sbrc r24,0
 906 02f2 00C0      		rjmp .L47
 496:main.c        ****       } else {
 908               	.LM79:
 909 02f4 83E0      		ldi r24,lo8(3)
 910 02f6 90E0      		ldi r25,0
 911 02f8 0E94 0000 		call nrk_led_set
 912 02fc 00C0      		rjmp .L46
 913               	.L47:
 498:main.c        ****       }      
 915               	.LM80:
 916 02fe 83E0      		ldi r24,lo8(3)
 917 0300 90E0      		ldi r25,0
 918 0302 0E94 0000 		call nrk_led_clr
 919 0306 11E0      		ldi r17,lo8(1)
 920               	.L46:
 503:main.c        ****       tx_node_queue_size = node_tx_queue.size;
 922               	.LM81:
 923 0308 8091 0000 		lds r24,node_tx_queue_mux
 924 030c 9091 0000 		lds r25,node_tx_queue_mux+1
 925 0310 0E94 0000 		call nrk_sem_pend
 504:main.c        ****     nrk_sem_post(node_tx_queue_mux);
 927               	.LM82:
 928 0314 7090 0000 		lds r7,node_tx_queue+138
 505:main.c        **** 
 930               	.LM83:
 931 0318 8091 0000 		lds r24,node_tx_queue_mux
 932 031c 9091 0000 		lds r25,node_tx_queue_mux+1
 933 0320 0E94 0000 		call nrk_sem_post
 934               	.LBB6:
 520:main.c        ****       // get a packet out of the queue.
 936               	.LM84:
 937 0324 00E0      		ldi r16,0
 938               	.L48:
 520:main.c        ****       // get a packet out of the queue.
 940               	.LM85:
 941 0326 0715      		cp r16,r7
 942 0328 01F4      		brne .+2
 943 032a 00C0      		rjmp .L59
 522:main.c        ****       pop(&node_tx_queue, &tx_packet);
 945               	.LM86:
 946 032c 8091 0000 		lds r24,node_tx_queue_mux
 947 0330 9091 0000 		lds r25,node_tx_queue_mux+1
 948 0334 0E94 0000 		call nrk_sem_pend
 523:main.c        ****       nrk_sem_post(node_tx_queue_mux);
 950               	.LM87:
 951 0338 BE01      		movw r22,r28
 952 033a 6F5F      		subi r22,-1
 953 033c 7F4F      		sbci r23,-1
 954 033e 80E0      		ldi r24,lo8(node_tx_queue)
 955 0340 90E0      		ldi r25,hi8(node_tx_queue)
 956 0342 0E94 0000 		call pop
 524:main.c        **** 
 958               	.LM88:
 959 0346 8091 0000 		lds r24,node_tx_queue_mux
 960 034a 9091 0000 		lds r25,node_tx_queue_mux+1
 961 034e 0E94 0000 		call nrk_sem_post
 528:main.c        ****       assemble_packet(&net_tx_buf, &tx_packet);
 963               	.LM89:
 964 0352 8091 0000 		lds r24,net_tx_buf_mux
 965 0356 9091 0000 		lds r25,net_tx_buf_mux+1
 966 035a 0E94 0000 		call nrk_sem_pend
 529:main.c        ****       // send the packet
 968               	.LM90:
 969 035e BE01      		movw r22,r28
 970 0360 6F5F      		subi r22,-1
 971 0362 7F4F      		sbci r23,-1
 972 0364 80E0      		ldi r24,lo8(net_tx_buf)
 973 0366 90E0      		ldi r25,hi8(net_tx_buf)
 974 0368 0E94 0000 		call assemble_packet
 531:main.c        ****       ret = nrk_event_wait (SIG(tx_done_signal));
 976               	.LM91:
 977 036c E0E0      		ldi r30,lo8(net_tx_buf)
 978 036e F0E0      		ldi r31,hi8(net_tx_buf)
 979               		0:
 980 0370 0190      		ld __tmp_reg__,Z+
 981 0372 0020      		tst __tmp_reg__
 982 0374 01F4      		brne 0b
 983 0376 3197      		sbiw r30,1
 984 0378 BF01      		movw r22,r30
 985 037a 6050      		subi r22,lo8(net_tx_buf)
 986 037c 7040      		sbci r23,hi8(net_tx_buf)
 987 037e 80E0      		ldi r24,lo8(net_tx_buf)
 988 0380 90E0      		ldi r25,hi8(net_tx_buf)
 989 0382 0E94 0000 		call bmac_tx_pkt_nonblocking
 532:main.c        ****       
 991               	.LM92:
 992 0386 C701      		movw r24,r14
 993 0388 B601      		movw r22,r12
 994 038a 0E94 0000 		call nrk_event_wait
 996               	.LM93:
 997 038e DC01      		movw r26,r24
 998 0390 CB01      		movw r24,r22
 999 0392 8821      		and r24,r8
 1000 0394 9921      		and r25,r9
 1001 0396 AA21      		and r26,r10
 1002 0398 BB21      		and r27,r11
 1003 039a 892B      		or r24,r25
 1004 039c 8A2B      		or r24,r26
 1005 039e 8B2B      		or r24,r27
 1006 03a0 01F0      		breq .L49
 536:main.c        ****         nrk_kprintf (PSTR ("TX done signal error\r\n"));
 1008               	.LM94:
 1009 03a2 80E0      		ldi r24,lo8(__c.3898)
 1010 03a4 90E0      		ldi r25,hi8(__c.3898)
 1011 03a6 0E94 0000 		call nrk_kprintf
 1012               	.L49:
 537:main.c        ****       }
 538:main.c        ****       nrk_sem_post(net_tx_buf_mux);     
 1014               	.LM95:
 1015 03aa 8091 0000 		lds r24,net_tx_buf_mux
 1016 03ae 9091 0000 		lds r25,net_tx_buf_mux+1
 1017 03b2 0E94 0000 		call nrk_sem_post
 520:main.c        ****       // get a packet out of the queue.
 1019               	.LM96:
 1020 03b6 0F5F      		subi r16,lo8(-(1))
 1021 03b8 00C0      		rjmp .L48
 1022               	.L59:
 1023               	.LBE6:
 539:main.c        ****     }
 540:main.c        ****     nrk_wait_until_next_period();
 1025               	.LM97:
 1026 03ba 0E94 0000 		call nrk_wait_until_next_period
 541:main.c        ****   }
 1028               	.LM98:
 1029 03be 00C0      		rjmp .L51
 1043               	.Lscope3:
 1045               		.stabd	78,0,0
 1046               		.section	.rodata.str1.1,"aMS",@progbits,1
 1047               	.LC0:
 1048 0000 2573 0D0A 		.string	"%s\r\n"
 1048      00
 1049               		.text
 1051               	.global	tx_serv_task
 1053               	tx_serv_task:
 1054               		.stabd	46,0,0
 542:main.c        **** }
 543:main.c        **** 
 544:main.c        **** /**
 545:main.c        ****  * tx_serv_task() _
 546:main.c        ****  *  send messages to the server
 547:main.c        ****  */
 548:main.c        **** void tx_serv_task() {
 1056               	.LM99:
 1057               	.LFBB4:
 1058 03c0 CF93      		push r28
 1059 03c2 DF93      		push r29
 1060 03c4 CDB7      		in r28,__SP_L__
 1061 03c6 DEB7      		in r29,__SP_H__
 1062 03c8 6197      		sbiw r28,17
 1063 03ca 0FB6      		in __tmp_reg__,__SREG__
 1064 03cc F894      		cli
 1065 03ce DEBF      		out __SP_H__,r29
 1066 03d0 0FBE      		out __SREG__,__tmp_reg__
 1067 03d2 CDBF      		out __SP_L__,r28
 1068               	/* prologue: function */
 1069               	/* frame size = 17 */
 1070               	/* stack size = 19 */
 1071               	.L__stack_usage = 19
 549:main.c        ****   // local variable initialization
 550:main.c        ****   uint8_t LED_FLAG = 0;
 1073               	.LM100:
 1074 03d4 10E0      		ldi r17,0
 1075               	.LBB7:
 551:main.c        ****   uint8_t tx_serv_queue_size;
 552:main.c        ****   packet tx_packet;
 553:main.c        **** 
 554:main.c        ****   while(1) {
 555:main.c        **** 
 556:main.c        ****     if(blink_leds == BLINKLEDS) {
 557:main.c        ****       LED_FLAG++;
 558:main.c        ****       LED_FLAG%=2;
 559:main.c        ****       if(LED_FLAG == 0) {
 560:main.c        ****         nrk_kprintf(PSTR("SERV LED ON\r\n"));
 561:main.c        ****       } else {
 562:main.c        ****         nrk_kprintf(PSTR("SERV LED OFF\r\n"));
 563:main.c        ****       }      
 564:main.c        ****     }
 565:main.c        **** 
 566:main.c        ****     // atomically get the queue size
 567:main.c        ****     nrk_sem_pend(serv_tx_queue_mux);
 568:main.c        ****       tx_serv_queue_size = serv_tx_queue.size;
 569:main.c        ****     nrk_sem_post(serv_tx_queue_mux);
 570:main.c        **** 
 571:main.c        ****     /**
 572:main.c        ****      * loop on queue size received above, and no more.
 573:main.c        ****      *  NOTE: during this loop the queue can be added to. If, for instance,
 574:main.c        ****      *    a "while(serv_tx_queue.size > 0)" was used a few bad things could happen
 575:main.c        ****      *      (1) a mutex would be required around the entire loop - BAD IDEA
 576:main.c        ****      *      (2) the queue could be added to while this loop is running, thus
 577:main.c        ****      *        making the loop unbounded - BAD IDEA
 578:main.c        ****      *      (3) the size the queue read and the actual size of the queue could be 
 579:main.c        ****      *        incorrect due to preemtion - BAD IDEA
 580:main.c        ****      *    Doing it this way bounds this loop to the maximum size of the queue
 581:main.c        ****      *    at any given time, regardless of whether or not the queue has been 
 582:main.c        ****      *    added to by another task.
 583:main.c        ****      */
 584:main.c        ****     for(uint8_t i = 0; i < tx_serv_queue_size; i++) {
 585:main.c        ****       // get a packet out of the queue.
 586:main.c        ****       nrk_sem_pend(serv_tx_queue_mux);
 587:main.c        ****       pop(&serv_tx_queue, &tx_packet);
 588:main.c        ****       nrk_sem_post(serv_tx_queue_mux);
 589:main.c        **** 
 590:main.c        ****       // NOTE: unlike tx_cmd_task() and tx_node_task(), no mutex is required around
 591:main.c        ****       //  the sending buffer here because tx_serv_task() is the only task to use
 592:main.c        ****       //  the serial transmitting buffer (serv_tx_buff);
 593:main.c        ****       assemble_serv_packet(&serv_tx_buf, &tx_packet);
 594:main.c        **** 
 595:main.c        ****       // send the packet
 596:main.c        ****       printf("%s\r\n", serv_tx_buf);
 1077               	.LM101:
 1078 03d6 80E0      		ldi r24,lo8(.LC0)
 1079 03d8 E82E      		mov r14,r24
 1080 03da 80E0      		ldi r24,hi8(.LC0)
 1081 03dc F82E      		mov r15,r24
 1082               	.L65:
 1083               	.LBE7:
 556:main.c        ****       LED_FLAG++;
 1085               	.LM102:
 1086 03de 8091 0000 		lds r24,blink_leds
 1087 03e2 8130      		cpi r24,lo8(1)
 1088 03e4 01F4      		brne .L61
 557:main.c        ****       LED_FLAG%=2;
 1090               	.LM103:
 1091 03e6 810F      		add r24,r17
 559:main.c        ****         nrk_kprintf(PSTR("SERV LED ON\r\n"));
 1093               	.LM104:
 1094 03e8 182F      		mov r17,r24
 1095 03ea 1170      		andi r17,lo8(1)
 1096 03ec 80FD      		sbrc r24,0
 1097 03ee 00C0      		rjmp .L62
 560:main.c        ****       } else {
 1099               	.LM105:
 1100 03f0 80E0      		ldi r24,lo8(__c.3909)
 1101 03f2 90E0      		ldi r25,hi8(__c.3909)
 1102 03f4 0E94 0000 		call nrk_kprintf
 1103 03f8 00C0      		rjmp .L61
 1104               	.L62:
 562:main.c        ****       }      
 1106               	.LM106:
 1107 03fa 80E0      		ldi r24,lo8(__c.3911)
 1108 03fc 90E0      		ldi r25,hi8(__c.3911)
 1109 03fe 0E94 0000 		call nrk_kprintf
 1110 0402 11E0      		ldi r17,lo8(1)
 1111               	.L61:
 567:main.c        ****       tx_serv_queue_size = serv_tx_queue.size;
 1113               	.LM107:
 1114 0404 8091 0000 		lds r24,serv_tx_queue_mux
 1115 0408 9091 0000 		lds r25,serv_tx_queue_mux+1
 1116 040c 0E94 0000 		call nrk_sem_pend
 568:main.c        ****     nrk_sem_post(serv_tx_queue_mux);
 1118               	.LM108:
 1119 0410 D090 0000 		lds r13,serv_tx_queue+138
 569:main.c        **** 
 1121               	.LM109:
 1122 0414 8091 0000 		lds r24,serv_tx_queue_mux
 1123 0418 9091 0000 		lds r25,serv_tx_queue_mux+1
 1124 041c 0E94 0000 		call nrk_sem_post
 1125               	.LBB8:
 584:main.c        ****       // get a packet out of the queue.
 1127               	.LM110:
 1128 0420 00E0      		ldi r16,0
 1129               	.L63:
 584:main.c        ****       // get a packet out of the queue.
 1131               	.LM111:
 1132 0422 0D15      		cp r16,r13
 1133 0424 01F0      		breq .L66
 586:main.c        ****       pop(&serv_tx_queue, &tx_packet);
 1135               	.LM112:
 1136 0426 8091 0000 		lds r24,serv_tx_queue_mux
 1137 042a 9091 0000 		lds r25,serv_tx_queue_mux+1
 1138 042e 0E94 0000 		call nrk_sem_pend
 587:main.c        ****       nrk_sem_post(serv_tx_queue_mux);
 1140               	.LM113:
 1141 0432 BE01      		movw r22,r28
 1142 0434 6F5F      		subi r22,-1
 1143 0436 7F4F      		sbci r23,-1
 1144 0438 80E0      		ldi r24,lo8(serv_tx_queue)
 1145 043a 90E0      		ldi r25,hi8(serv_tx_queue)
 1146 043c 0E94 0000 		call pop
 588:main.c        **** 
 1148               	.LM114:
 1149 0440 8091 0000 		lds r24,serv_tx_queue_mux
 1150 0444 9091 0000 		lds r25,serv_tx_queue_mux+1
 1151 0448 0E94 0000 		call nrk_sem_post
 593:main.c        **** 
 1153               	.LM115:
 1154 044c BE01      		movw r22,r28
 1155 044e 6F5F      		subi r22,-1
 1156 0450 7F4F      		sbci r23,-1
 1157 0452 80E0      		ldi r24,lo8(serv_tx_buf)
 1158 0454 90E0      		ldi r25,hi8(serv_tx_buf)
 1159 0456 0E94 0000 		call assemble_serv_packet
 1161               	.LM116:
 1162 045a 80E0      		ldi r24,lo8(serv_tx_buf)
 1163 045c 90E0      		ldi r25,hi8(serv_tx_buf)
 1164 045e 9F93      		push r25
 1165 0460 8F93      		push r24
 1166 0462 FF92      		push r15
 1167 0464 EF92      		push r14
 1168 0466 0E94 0000 		call printf
 584:main.c        ****       // get a packet out of the queue.
 1170               	.LM117:
 1171 046a 0F5F      		subi r16,lo8(-(1))
 1172 046c 0F90      		pop __tmp_reg__
 1173 046e 0F90      		pop __tmp_reg__
 1174 0470 0F90      		pop __tmp_reg__
 1175 0472 0F90      		pop __tmp_reg__
 1176 0474 00C0      		rjmp .L63
 1177               	.L66:
 1178               	.LBE8:
 597:main.c        ****     }
 598:main.c        ****     nrk_wait_until_next_period();
 1180               	.LM118:
 1181 0476 0E94 0000 		call nrk_wait_until_next_period
 599:main.c        ****   }
 1183               	.LM119:
 1184 047a 00C0      		rjmp .L65
 1196               	.Lscope4:
 1198               		.stabd	78,0,0
 1200               	.global	clear_serv_buf
 1202               	clear_serv_buf:
 1203               		.stabd	46,0,0
 173:main.c        ****   for(uint8_t i = 0; i < serv_rx_index; i++) {
 1205               	.LM120:
 1206               	.LFBB5:
 1207               	/* prologue: function */
 1208               	/* frame size = 0 */
 1209               	/* stack size = 0 */
 1210               	.L__stack_usage = 0
 1211               	.LBB9:
 174:main.c        ****     serv_rx_buf[i] = '\0';
 1213               	.LM121:
 1214 047c 8091 0000 		lds r24,serv_rx_index
 1215 0480 20E0      		ldi r18,lo8(serv_rx_buf)
 1216 0482 30E0      		ldi r19,hi8(serv_rx_buf)
 1217 0484 F901      		movw r30,r18
 1218               	.L68:
 1219 0486 9E2F      		mov r25,r30
 1220 0488 921B      		sub r25,r18
 174:main.c        ****     serv_rx_buf[i] = '\0';
 1222               	.LM122:
 1223 048a 9817      		cp r25,r24
 1224 048c 00F4      		brsh .L70
 175:main.c        ****   }
 1226               	.LM123:
 1227 048e 1192      		st Z+,__zero_reg__
 1228 0490 00C0      		rjmp .L68
 1229               	.L70:
 1230               	.LBE9:
 177:main.c        **** }
 1232               	.LM124:
 1233 0492 1092 0000 		sts serv_rx_index,__zero_reg__
 1234 0496 0895      		ret
 1236               	.Lscope5:
 1238               		.stabd	78,0,0
 1240               	.global	get_server_input
 1242               	get_server_input:
 1243               		.stabd	46,0,0
 130:main.c        ****   uint8_t option;
 1245               	.LM125:
 1246               	.LFBB6:
 1247 0498 1F93      		push r17
 1248 049a CF93      		push r28
 1249 049c DF93      		push r29
 1250               	/* prologue: function */
 1251               	/* frame size = 0 */
 1252               	/* stack size = 3 */
 1253               	.L__stack_usage = 3
 1254               	.L72:
 134:main.c        **** 
 1256               	.LM126:
 1257 049e 80E0      		ldi r24,0
 1258 04a0 0E94 0000 		call nrk_uart_data_ready
 1259 04a4 C82F      		mov r28,r24
 1260 04a6 8823      		tst r24
 1261 04a8 01F4      		brne .+2
 1262 04aa 00C0      		rjmp .L76
 137:main.c        **** 
 1264               	.LM127:
 1265 04ac 8091 0000 		lds r24,__iob
 1266 04b0 9091 0000 		lds r25,__iob+1
 1267 04b4 0E94 0000 		call fgetc
 1268 04b8 EC01      		movw r28,r24
 1269 04ba 182F      		mov r17,r24
 140:main.c        ****       serv_rx_buf[serv_rx_index] = option;
 1271               	.LM128:
 1272 04bc 9091 0000 		lds r25,serv_rx_index
 1273 04c0 9337      		cpi r25,lo8(115)
 1274 04c2 00F4      		brsh .L73
 141:main.c        ****       serv_rx_index++;      
 1276               	.LM129:
 1277 04c4 E92F      		mov r30,r25
 1278 04c6 F0E0      		ldi r31,0
 1279 04c8 E050      		subi r30,lo8(-(serv_rx_buf))
 1280 04ca F040      		sbci r31,hi8(-(serv_rx_buf))
 1281 04cc C083      		st Z,r28
 142:main.c        ****     } 
 1283               	.LM130:
 1284 04ce 9F5F      		subi r25,lo8(-(1))
 1285 04d0 9093 0000 		sts serv_rx_index,r25
 1286 04d4 00C0      		rjmp .L74
 1287               	.L73:
 146:main.c        ****       serv_rx_buf[serv_rx_index] = option;
 1289               	.LM131:
 1290 04d6 0E94 0000 		call clear_serv_buf
 147:main.c        ****       serv_rx_index++;
 1292               	.LM132:
 1293 04da 8091 0000 		lds r24,serv_rx_index
 1294 04de E82F      		mov r30,r24
 1295 04e0 F0E0      		ldi r31,0
 1296 04e2 E050      		subi r30,lo8(-(serv_rx_buf))
 1297 04e4 F040      		sbci r31,hi8(-(serv_rx_buf))
 1298 04e6 C083      		st Z,r28
 148:main.c        ****     }
 1300               	.LM133:
 1301 04e8 8F5F      		subi r24,lo8(-(1))
 1302 04ea 8093 0000 		sts serv_rx_index,r24
 1303               	.L74:
 152:main.c        ****       printf("%c", option);
 1305               	.LM134:
 1306 04ee 8091 0000 		lds r24,print_incoming
 1307 04f2 8130      		cpi r24,lo8(1)
 1308 04f4 01F4      		brne .L75
 153:main.c        ****     }
 1310               	.LM135:
 1311 04f6 CE01      		movw r24,r28
 1312 04f8 9927      		clr r25
 1313 04fa 0E94 0000 		call putchar
 1314               	.L75:
 157:main.c        ****       serv_rx_buf[serv_rx_index] = '\n';
 1316               	.LM136:
 1317 04fe 1D30      		cpi r17,lo8(13)
 1318 0500 01F4      		brne .L72
 1319               	.LBB13:
 1320               	.LBB14:
 158:main.c        ****       serv_rx_index++;
 1322               	.LM137:
 1323 0502 8091 0000 		lds r24,serv_rx_index
 1324 0506 E82F      		mov r30,r24
 1325 0508 F0E0      		ldi r31,0
 1326 050a E050      		subi r30,lo8(-(serv_rx_buf))
 1327 050c F040      		sbci r31,hi8(-(serv_rx_buf))
 1328 050e 9AE0      		ldi r25,lo8(10)
 1329 0510 9083      		st Z,r25
 159:main.c        ****       if(print_incoming == PRINT2TERM) {
 1331               	.LM138:
 1332 0512 8F5F      		subi r24,lo8(-(1))
 1333 0514 8093 0000 		sts serv_rx_index,r24
 160:main.c        ****         nrk_kprintf(PSTR("\n"));
 1335               	.LM139:
 1336 0518 C091 0000 		lds r28,print_incoming
 1337 051c C130      		cpi r28,lo8(1)
 1338 051e 01F4      		brne .L78
 161:main.c        ****       }
 1340               	.LM140:
 1341 0520 80E0      		ldi r24,lo8(__c.3809)
 1342 0522 90E0      		ldi r25,hi8(__c.3809)
 1343 0524 0E94 0000 		call nrk_kprintf
 1344 0528 00C0      		rjmp .L76
 1345               	.L78:
 160:main.c        ****         nrk_kprintf(PSTR("\n"));
 1347               	.LM141:
 1348 052a C1E0      		ldi r28,lo8(1)
 1349               	.L76:
 1350               	.LBE14:
 1351               	.LBE13:
 167:main.c        **** 
 1353               	.LM142:
 1354 052c 8C2F      		mov r24,r28
 1355               	/* epilogue start */
 1356 052e DF91      		pop r29
 1357 0530 CF91      		pop r28
 1358 0532 1F91      		pop r17
 1359 0534 0895      		ret
 1364               	.Lscope6:
 1366               		.stabd	78,0,0
 1367               		.section	.rodata.str1.1
 1368               	.LC1:
 1369 0005 2573 00   		.string	"%s"
 1370               		.text
 1372               	.global	rx_serv_task
 1374               	rx_serv_task:
 1375               		.stabd	46,0,0
 306:main.c        ****   // local variable instantiation
 1377               	.LM143:
 1378               	.LFBB7:
 1379 0536 CF93      		push r28
 1380 0538 DF93      		push r29
 1381 053a CDB7      		in r28,__SP_L__
 1382 053c DEB7      		in r29,__SP_H__
 1383 053e 6197      		sbiw r28,17
 1384 0540 0FB6      		in __tmp_reg__,__SREG__
 1385 0542 F894      		cli
 1386 0544 DEBF      		out __SP_H__,r29
 1387 0546 0FBE      		out __SREG__,__tmp_reg__
 1388 0548 CDBF      		out __SP_L__,r28
 1389               	/* prologue: function */
 1390               	/* frame size = 17 */
 1391               	/* stack size = 19 */
 1392               	.L__stack_usage = 19
 312:main.c        ****   nrk_signal_register(uart_rx_signal);
 1394               	.LM144:
 1395 054a 0E94 0000 		call nrk_uart_rx_signal_get
 313:main.c        ****   
 1397               	.LM145:
 1398 054e 0E94 0000 		call nrk_signal_register
 308:main.c        ****   packet rx_packet;
 1400               	.LM146:
 1401 0552 10E0      		ldi r17,0
 333:main.c        ****       }
 1403               	.LM147:
 1404 0554 80E0      		ldi r24,lo8(.LC1)
 1405 0556 E82E      		mov r14,r24
 1406 0558 80E0      		ldi r24,hi8(.LC1)
 1407 055a F82E      		mov r15,r24
 1408               	.L88:
 318:main.c        ****       LED_FLAG++;
 1410               	.LM148:
 1411 055c 8091 0000 		lds r24,blink_leds
 1412 0560 8130      		cpi r24,lo8(1)
 1413 0562 01F4      		brne .L81
 319:main.c        ****       LED_FLAG%=2;
 1415               	.LM149:
 1416 0564 810F      		add r24,r17
 321:main.c        ****         nrk_led_set(1);
 1418               	.LM150:
 1419 0566 182F      		mov r17,r24
 1420 0568 1170      		andi r17,lo8(1)
 1421 056a 80FD      		sbrc r24,0
 1422 056c 00C0      		rjmp .L82
 322:main.c        ****       } else {
 1424               	.LM151:
 1425 056e 81E0      		ldi r24,lo8(1)
 1426 0570 90E0      		ldi r25,0
 1427 0572 0E94 0000 		call nrk_led_set
 1428 0576 00C0      		rjmp .L81
 1429               	.L82:
 324:main.c        ****       }      
 1431               	.LM152:
 1432 0578 81E0      		ldi r24,lo8(1)
 1433 057a 90E0      		ldi r25,0
 1434 057c 0E94 0000 		call nrk_led_clr
 1435 0580 11E0      		ldi r17,lo8(1)
 1436               	.L81:
 329:main.c        **** 
 1438               	.LM153:
 1439 0582 0E94 0000 		call get_server_input
 1440 0586 8130      		cpi r24,lo8(1)
 1441 0588 01F4      		brne .L84
 332:main.c        ****         printf("%s", serv_rx_buf);     
 1443               	.LM154:
 1444 058a 8091 0000 		lds r24,print_incoming
 1445 058e 8130      		cpi r24,lo8(1)
 1446 0590 01F4      		brne .L85
 333:main.c        ****       }
 1448               	.LM155:
 1449 0592 80E0      		ldi r24,lo8(serv_rx_buf)
 1450 0594 90E0      		ldi r25,hi8(serv_rx_buf)
 1451 0596 9F93      		push r25
 1452 0598 8F93      		push r24
 1453 059a FF92      		push r15
 1454 059c EF92      		push r14
 1455 059e 0E94 0000 		call printf
 1456 05a2 0F90      		pop __tmp_reg__
 1457 05a4 0F90      		pop __tmp_reg__
 1458 05a6 0F90      		pop __tmp_reg__
 1459 05a8 0F90      		pop __tmp_reg__
 1460               	.L85:
 337:main.c        ****       clear_serv_buf();
 1462               	.LM156:
 1463 05aa 4091 0000 		lds r20,serv_rx_index
 1464 05ae 60E0      		ldi r22,lo8(serv_rx_buf)
 1465 05b0 70E0      		ldi r23,hi8(serv_rx_buf)
 1466 05b2 CE01      		movw r24,r28
 1467 05b4 0196      		adiw r24,1
 1468 05b6 0E94 0000 		call parse_serv_msg
 338:main.c        **** 
 1470               	.LM157:
 1471 05ba 0E94 0000 		call clear_serv_buf
 346:main.c        **** 
 1473               	.LM158:
 1474 05be 8B81      		ldd r24,Y+3
 1475 05c0 9C81      		ldd r25,Y+4
 1476 05c2 2091 0000 		lds r18,server_seq_num
 1477 05c6 3091 0000 		lds r19,server_seq_num+1
 1478 05ca 2817      		cp r18,r24
 1479 05cc 3907      		cpc r19,r25
 1480 05ce 00F4      		brsh .L84
 349:main.c        **** 
 1482               	.LM159:
 1483 05d0 9093 0000 		sts server_seq_num+1,r25
 1484 05d4 8093 0000 		sts server_seq_num,r24
 352:main.c        ****           // if a command
 1486               	.LM160:
 1487 05d8 8A81      		ldd r24,Y+2
 1488 05da 8630      		cpi r24,lo8(6)
 1489 05dc 01F4      		brne .L84
 357:main.c        ****             push(&cmd_tx_queue, &rx_packet);
 1491               	.LM161:
 1492 05de 8091 0000 		lds r24,cmd_tx_queue_mux
 1493 05e2 9091 0000 		lds r25,cmd_tx_queue_mux+1
 1494 05e6 0E94 0000 		call nrk_sem_pend
 358:main.c        ****             nrk_sem_post(cmd_tx_queue_mux);
 1496               	.LM162:
 1497 05ea BE01      		movw r22,r28
 1498 05ec 6F5F      		subi r22,-1
 1499 05ee 7F4F      		sbci r23,-1
 1500 05f0 80E0      		ldi r24,lo8(cmd_tx_queue)
 1501 05f2 90E0      		ldi r25,hi8(cmd_tx_queue)
 1502 05f4 0E94 0000 		call push
 359:main.c        ****             break;
 1504               	.LM163:
 1505 05f8 8091 0000 		lds r24,cmd_tx_queue_mux
 1506 05fc 9091 0000 		lds r25,cmd_tx_queue_mux+1
 1507 0600 0E94 0000 		call nrk_sem_post
 1508               	.L84:
 381:main.c        ****   }
 1510               	.LM164:
 1511 0604 0E94 0000 		call nrk_wait_until_next_period
 382:main.c        **** }
 1513               	.LM165:
 1514 0608 00C0      		rjmp .L88
 1519               	.Lscope7:
 1521               		.stabd	78,0,0
 1523               	.global	clear_tx_buf
 1525               	clear_tx_buf:
 1526               		.stabd	46,0,0
 180:main.c        ****   for(uint8_t i = 0; i < net_tx_index; i++){
 1528               	.LM166:
 1529               	.LFBB8:
 1530               	/* prologue: function */
 1531               	/* frame size = 0 */
 1532               	/* stack size = 0 */
 1533               	.L__stack_usage = 0
 1534               	.LBB15:
 181:main.c        ****     net_tx_buf[i] = 0;
 1536               	.LM167:
 1537 060a 8091 0000 		lds r24,net_tx_index
 1538 060e 20E0      		ldi r18,lo8(net_tx_buf)
 1539 0610 30E0      		ldi r19,hi8(net_tx_buf)
 1540 0612 F901      		movw r30,r18
 1541               	.L90:
 1542 0614 9E2F      		mov r25,r30
 1543 0616 921B      		sub r25,r18
 181:main.c        ****     net_tx_buf[i] = 0;
 1545               	.LM168:
 1546 0618 9817      		cp r25,r24
 1547 061a 00F4      		brsh .L92
 182:main.c        ****   }
 1549               	.LM169:
 1550 061c 1192      		st Z+,__zero_reg__
 1551 061e 00C0      		rjmp .L90
 1552               	.L92:
 1553               	.LBE15:
 184:main.c        **** }
 1555               	.LM170:
 1556 0620 1092 0000 		sts net_tx_index,__zero_reg__
 1557 0624 0895      		ret
 1559               	.Lscope8:
 1561               		.stabd	78,0,0
 1563               	.global	nrk_create_taskset
 1565               	nrk_create_taskset:
 1566               		.stabd	46,0,0
 600:main.c        **** }
 601:main.c        **** 
 602:main.c        **** /**
 603:main.c        ****  * nrk_create_taskset - create the tasks in this application
 604:main.c        ****  * 
 605:main.c        ****  * NOTE: task priority maps to importance. That is, priority(5) > priority(2).
 606:main.c        ****  */
 607:main.c        **** void nrk_create_taskset () {
 1568               	.LM171:
 1569               	.LFBB9:
 1570 0626 8F92      		push r8
 1571 0628 9F92      		push r9
 1572 062a AF92      		push r10
 1573 062c BF92      		push r11
 1574 062e CF92      		push r12
 1575 0630 DF92      		push r13
 1576 0632 EF92      		push r14
 1577 0634 FF92      		push r15
 1578 0636 0F93      		push r16
 1579 0638 1F93      		push r17
 1580 063a CF93      		push r28
 1581               	/* prologue: function */
 1582               	/* frame size = 0 */
 1583               	/* stack size = 11 */
 1584               	.L__stack_usage = 11
 608:main.c        ****   // PRIORITY 5 - HIGHEST PRIORITY
 609:main.c        ****   RX_NODE_TASK.task = rx_node_task;
 1586               	.LM172:
 1587 063c 00E0      		ldi r16,lo8(RX_NODE_TASK)
 1588 063e 10E0      		ldi r17,hi8(RX_NODE_TASK)
 1589 0640 80E0      		ldi r24,lo8(gs(rx_node_task))
 1590 0642 90E0      		ldi r25,hi8(gs(rx_node_task))
 1591 0644 F801      		movw r30,r16
 1592 0646 9683      		std Z+6,r25
 1593 0648 8583      		std Z+5,r24
 610:main.c        ****   nrk_task_set_stk(&RX_NODE_TASK, rx_node_task_stack, NRK_APP_STACKSIZE);
 1595               	.LM173:
 1596 064a 40E0      		ldi r20,0
 1597 064c 52E0      		ldi r21,lo8(2)
 1598 064e 60E0      		ldi r22,lo8(rx_node_task_stack)
 1599 0650 70E0      		ldi r23,hi8(rx_node_task_stack)
 1600 0652 C801      		movw r24,r16
 1601 0654 0E94 0000 		call nrk_task_set_stk
 611:main.c        ****   RX_NODE_TASK.prio = 5;
 1603               	.LM174:
 1604 0658 85E0      		ldi r24,lo8(5)
 1605 065a F801      		movw r30,r16
 1606 065c 8087      		std Z+8,r24
 612:main.c        ****   RX_NODE_TASK.FirstActivation = TRUE;
 1608               	.LM175:
 1609 065e C1E0      		ldi r28,lo8(1)
 1610 0660 C783      		std Z+7,r28
 613:main.c        ****   RX_NODE_TASK.Type = BASIC_TASK;
 1612               	.LM176:
 1613 0662 C187      		std Z+9,r28
 614:main.c        ****   RX_NODE_TASK.SchType = PREEMPTIVE;
 1615               	.LM177:
 1616 0664 C287      		std Z+10,r28
 615:main.c        ****   RX_NODE_TASK.period.secs = 0;
 1618               	.LM178:
 1619 0666 1386      		std Z+11,__zero_reg__
 1620 0668 1486      		std Z+12,__zero_reg__
 1621 066a 1586      		std Z+13,__zero_reg__
 1622 066c 1686      		std Z+14,__zero_reg__
 616:main.c        ****   RX_NODE_TASK.period.nano_secs = 50*NANOS_PER_MS;
 1624               	.LM179:
 1625 066e 80E8      		ldi r24,lo8(-128)
 1626 0670 C82E      		mov r12,r24
 1627 0672 80EF      		ldi r24,lo8(-16)
 1628 0674 D82E      		mov r13,r24
 1629 0676 8AEF      		ldi r24,lo8(-6)
 1630 0678 E82E      		mov r14,r24
 1631 067a 82E0      		ldi r24,lo8(2)
 1632 067c F82E      		mov r15,r24
 1633 067e C786      		std Z+15,r12
 1634 0680 D08A      		std Z+16,r13
 1635 0682 E18A      		std Z+17,r14
 1636 0684 F28A      		std Z+18,r15
 617:main.c        ****   RX_NODE_TASK.cpu_reserve.secs = 0;
 1638               	.LM180:
 1639 0686 138A      		std Z+19,__zero_reg__
 1640 0688 148A      		std Z+20,__zero_reg__
 1641 068a 158A      		std Z+21,__zero_reg__
 1642 068c 168A      		std Z+22,__zero_reg__
 618:main.c        ****   RX_NODE_TASK.cpu_reserve.nano_secs = 10*NANOS_PER_MS;
 1644               	.LM181:
 1645 068e 90E8      		ldi r25,lo8(-128)
 1646 0690 892E      		mov r8,r25
 1647 0692 96E9      		ldi r25,lo8(-106)
 1648 0694 992E      		mov r9,r25
 1649 0696 98E9      		ldi r25,lo8(-104)
 1650 0698 A92E      		mov r10,r25
 1651 069a B12C      		mov r11,__zero_reg__
 1652 069c 878A      		std Z+23,r8
 1653 069e 908E      		std Z+24,r9
 1654 06a0 A18E      		std Z+25,r10
 1655 06a2 B28E      		std Z+26,r11
 619:main.c        ****   RX_NODE_TASK.offset.secs = 0;
 1657               	.LM182:
 1658 06a4 138E      		std Z+27,__zero_reg__
 1659 06a6 148E      		std Z+28,__zero_reg__
 1660 06a8 158E      		std Z+29,__zero_reg__
 1661 06aa 168E      		std Z+30,__zero_reg__
 620:main.c        ****   RX_NODE_TASK.offset.nano_secs = 0;
 1663               	.LM183:
 1664 06ac 178E      		std Z+31,__zero_reg__
 1665 06ae 10A2      		std Z+32,__zero_reg__
 1666 06b0 11A2      		std Z+33,__zero_reg__
 1667 06b2 12A2      		std Z+34,__zero_reg__
 621:main.c        ****   nrk_activate_task(&RX_NODE_TASK);
 1669               	.LM184:
 1670 06b4 C801      		movw r24,r16
 1671 06b6 0E94 0000 		call nrk_activate_task
 622:main.c        **** 
 623:main.c        ****   // PRIORITY 4 - SECOND HIGHEST PRIORITY
 624:main.c        ****   RX_SERV_TASK.task = rx_serv_task;
 1673               	.LM185:
 1674 06ba 00E0      		ldi r16,lo8(RX_SERV_TASK)
 1675 06bc 10E0      		ldi r17,hi8(RX_SERV_TASK)
 1676 06be 80E0      		ldi r24,lo8(gs(rx_serv_task))
 1677 06c0 90E0      		ldi r25,hi8(gs(rx_serv_task))
 1678 06c2 F801      		movw r30,r16
 1679 06c4 9683      		std Z+6,r25
 1680 06c6 8583      		std Z+5,r24
 625:main.c        ****   nrk_task_set_stk(&RX_SERV_TASK, rx_serv_task, NRK_APP_STACKSIZE);
 1682               	.LM186:
 1683 06c8 40E0      		ldi r20,0
 1684 06ca 52E0      		ldi r21,lo8(2)
 1685 06cc BC01      		movw r22,r24
 1686 06ce C801      		movw r24,r16
 1687 06d0 0E94 0000 		call nrk_task_set_stk
 626:main.c        ****   RX_SERV_TASK.prio = 4;
 1689               	.LM187:
 1690 06d4 84E0      		ldi r24,lo8(4)
 1691 06d6 F801      		movw r30,r16
 1692 06d8 8087      		std Z+8,r24
 627:main.c        ****   RX_SERV_TASK.FirstActivation = TRUE;
 1694               	.LM188:
 1695 06da C783      		std Z+7,r28
 628:main.c        ****   RX_SERV_TASK.Type = BASIC_TASK;
 1697               	.LM189:
 1698 06dc C187      		std Z+9,r28
 629:main.c        ****   RX_SERV_TASK.SchType = PREEMPTIVE;
 1700               	.LM190:
 1701 06de C287      		std Z+10,r28
 630:main.c        ****   RX_SERV_TASK.period.secs = 0;
 1703               	.LM191:
 1704 06e0 1386      		std Z+11,__zero_reg__
 1705 06e2 1486      		std Z+12,__zero_reg__
 1706 06e4 1586      		std Z+13,__zero_reg__
 1707 06e6 1686      		std Z+14,__zero_reg__
 631:main.c        ****   RX_SERV_TASK.period.nano_secs = 50*NANOS_PER_MS;
 1709               	.LM192:
 1710 06e8 C786      		std Z+15,r12
 1711 06ea D08A      		std Z+16,r13
 1712 06ec E18A      		std Z+17,r14
 1713 06ee F28A      		std Z+18,r15
 632:main.c        ****   RX_SERV_TASK.cpu_reserve.secs = 0;
 1715               	.LM193:
 1716 06f0 138A      		std Z+19,__zero_reg__
 1717 06f2 148A      		std Z+20,__zero_reg__
 1718 06f4 158A      		std Z+21,__zero_reg__
 1719 06f6 168A      		std Z+22,__zero_reg__
 633:main.c        ****   RX_SERV_TASK.cpu_reserve.nano_secs = 10*NANOS_PER_MS;
 1721               	.LM194:
 1722 06f8 878A      		std Z+23,r8
 1723 06fa 908E      		std Z+24,r9
 1724 06fc A18E      		std Z+25,r10
 1725 06fe B28E      		std Z+26,r11
 634:main.c        ****   RX_SERV_TASK.offset.secs = 0;
 1727               	.LM195:
 1728 0700 138E      		std Z+27,__zero_reg__
 1729 0702 148E      		std Z+28,__zero_reg__
 1730 0704 158E      		std Z+29,__zero_reg__
 1731 0706 168E      		std Z+30,__zero_reg__
 635:main.c        ****   RX_SERV_TASK.offset.nano_secs = 0;
 1733               	.LM196:
 1734 0708 178E      		std Z+31,__zero_reg__
 1735 070a 10A2      		std Z+32,__zero_reg__
 1736 070c 11A2      		std Z+33,__zero_reg__
 1737 070e 12A2      		std Z+34,__zero_reg__
 636:main.c        ****   nrk_activate_task(&RX_SERV_TASK);
 1739               	.LM197:
 1740 0710 C801      		movw r24,r16
 1741 0712 0E94 0000 		call nrk_activate_task
 637:main.c        ****   
 638:main.c        ****   // PRIORITY 3 - MIDDLE PRIORITY
 639:main.c        ****   TX_CMD_TASK.task = tx_cmd_task;
 1743               	.LM198:
 1744 0716 00E0      		ldi r16,lo8(TX_CMD_TASK)
 1745 0718 10E0      		ldi r17,hi8(TX_CMD_TASK)
 1746 071a 80E0      		ldi r24,lo8(gs(tx_cmd_task))
 1747 071c 90E0      		ldi r25,hi8(gs(tx_cmd_task))
 1748 071e F801      		movw r30,r16
 1749 0720 9683      		std Z+6,r25
 1750 0722 8583      		std Z+5,r24
 640:main.c        ****   nrk_task_set_stk(&TX_CMD_TASK, tx_cmd_task_stack, NRK_APP_STACKSIZE);
 1752               	.LM199:
 1753 0724 40E0      		ldi r20,0
 1754 0726 52E0      		ldi r21,lo8(2)
 1755 0728 60E0      		ldi r22,lo8(tx_cmd_task_stack)
 1756 072a 70E0      		ldi r23,hi8(tx_cmd_task_stack)
 1757 072c C801      		movw r24,r16
 1758 072e 0E94 0000 		call nrk_task_set_stk
 641:main.c        ****   TX_CMD_TASK.prio = 3;
 1760               	.LM200:
 1761 0732 83E0      		ldi r24,lo8(3)
 1762 0734 F801      		movw r30,r16
 1763 0736 8087      		std Z+8,r24
 642:main.c        ****   TX_CMD_TASK.FirstActivation = TRUE;
 1765               	.LM201:
 1766 0738 C783      		std Z+7,r28
 643:main.c        ****   TX_CMD_TASK.Type = BASIC_TASK;
 1768               	.LM202:
 1769 073a C187      		std Z+9,r28
 644:main.c        ****   TX_CMD_TASK.SchType = PREEMPTIVE;
 1771               	.LM203:
 1772 073c C287      		std Z+10,r28
 645:main.c        ****   TX_CMD_TASK.period.secs = 0;
 1774               	.LM204:
 1775 073e 1386      		std Z+11,__zero_reg__
 1776 0740 1486      		std Z+12,__zero_reg__
 1777 0742 1586      		std Z+13,__zero_reg__
 1778 0744 1686      		std Z+14,__zero_reg__
 646:main.c        ****   TX_CMD_TASK.period.nano_secs = 150*NANOS_PER_MS;
 1780               	.LM205:
 1781 0746 80E8      		ldi r24,lo8(-128)
 1782 0748 91ED      		ldi r25,lo8(-47)
 1783 074a A0EF      		ldi r26,lo8(-16)
 1784 074c B8E0      		ldi r27,lo8(8)
 1785 074e 8787      		std Z+15,r24
 1786 0750 908B      		std Z+16,r25
 1787 0752 A18B      		std Z+17,r26
 1788 0754 B28B      		std Z+18,r27
 647:main.c        ****   TX_CMD_TASK.cpu_reserve.secs = 0;
 1790               	.LM206:
 1791 0756 138A      		std Z+19,__zero_reg__
 1792 0758 148A      		std Z+20,__zero_reg__
 1793 075a 158A      		std Z+21,__zero_reg__
 1794 075c 168A      		std Z+22,__zero_reg__
 648:main.c        ****   TX_CMD_TASK.cpu_reserve.nano_secs = 50*NANOS_PER_MS;
 1796               	.LM207:
 1797 075e C78A      		std Z+23,r12
 1798 0760 D08E      		std Z+24,r13
 1799 0762 E18E      		std Z+25,r14
 1800 0764 F28E      		std Z+26,r15
 649:main.c        ****   TX_CMD_TASK.offset.secs = 0;
 1802               	.LM208:
 1803 0766 138E      		std Z+27,__zero_reg__
 1804 0768 148E      		std Z+28,__zero_reg__
 1805 076a 158E      		std Z+29,__zero_reg__
 1806 076c 168E      		std Z+30,__zero_reg__
 650:main.c        ****   TX_CMD_TASK.offset.nano_secs = 0;
 1808               	.LM209:
 1809 076e 178E      		std Z+31,__zero_reg__
 1810 0770 10A2      		std Z+32,__zero_reg__
 1811 0772 11A2      		std Z+33,__zero_reg__
 1812 0774 12A2      		std Z+34,__zero_reg__
 651:main.c        ****   nrk_activate_task(&TX_CMD_TASK);
 1814               	.LM210:
 1815 0776 C801      		movw r24,r16
 1816 0778 0E94 0000 		call nrk_activate_task
 652:main.c        **** 
 653:main.c        **** 
 654:main.c        ****   // PRIORITY 2 - SECOND LOWEST PRIORITY
 655:main.c        ****   TX_NODE_TASK.task = tx_node_task;
 1818               	.LM211:
 1819 077c 00E0      		ldi r16,lo8(TX_NODE_TASK)
 1820 077e 10E0      		ldi r17,hi8(TX_NODE_TASK)
 1821 0780 80E0      		ldi r24,lo8(gs(tx_node_task))
 1822 0782 90E0      		ldi r25,hi8(gs(tx_node_task))
 1823 0784 F801      		movw r30,r16
 1824 0786 9683      		std Z+6,r25
 1825 0788 8583      		std Z+5,r24
 656:main.c        ****   nrk_task_set_stk(&TX_NODE_TASK, tx_node_task_stack, NRK_APP_STACKSIZE);
 1827               	.LM212:
 1828 078a 40E0      		ldi r20,0
 1829 078c 52E0      		ldi r21,lo8(2)
 1830 078e 60E0      		ldi r22,lo8(tx_node_task_stack)
 1831 0790 70E0      		ldi r23,hi8(tx_node_task_stack)
 1832 0792 C801      		movw r24,r16
 1833 0794 0E94 0000 		call nrk_task_set_stk
 657:main.c        ****   TX_NODE_TASK.prio = 2;
 1835               	.LM213:
 1836 0798 82E0      		ldi r24,lo8(2)
 1837 079a F801      		movw r30,r16
 1838 079c 8087      		std Z+8,r24
 658:main.c        ****   TX_NODE_TASK.FirstActivation = TRUE;
 1840               	.LM214:
 1841 079e C783      		std Z+7,r28
 659:main.c        ****   TX_NODE_TASK.Type = BASIC_TASK;
 1843               	.LM215:
 1844 07a0 C187      		std Z+9,r28
 660:main.c        ****   TX_NODE_TASK.SchType = PREEMPTIVE;
 1846               	.LM216:
 1847 07a2 C287      		std Z+10,r28
 661:main.c        ****   TX_NODE_TASK.period.secs = 5;
 1849               	.LM217:
 1850 07a4 25E0      		ldi r18,lo8(5)
 1851 07a6 822E      		mov r8,r18
 1852 07a8 912C      		mov r9,__zero_reg__
 1853 07aa A12C      		mov r10,__zero_reg__
 1854 07ac B12C      		mov r11,__zero_reg__
 1855 07ae 8386      		std Z+11,r8
 1856 07b0 9486      		std Z+12,r9
 1857 07b2 A586      		std Z+13,r10
 1858 07b4 B686      		std Z+14,r11
 662:main.c        ****   TX_NODE_TASK.period.nano_secs = 0;
 1860               	.LM218:
 1861 07b6 1786      		std Z+15,__zero_reg__
 1862 07b8 108A      		std Z+16,__zero_reg__
 1863 07ba 118A      		std Z+17,__zero_reg__
 1864 07bc 128A      		std Z+18,__zero_reg__
 663:main.c        ****   TX_NODE_TASK.cpu_reserve.secs = 0;
 1866               	.LM219:
 1867 07be 138A      		std Z+19,__zero_reg__
 1868 07c0 148A      		std Z+20,__zero_reg__
 1869 07c2 158A      		std Z+21,__zero_reg__
 1870 07c4 168A      		std Z+22,__zero_reg__
 664:main.c        ****   TX_NODE_TASK.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 1872               	.LM220:
 1873 07c6 C12C      		mov r12,__zero_reg__
 1874 07c8 31EE      		ldi r19,lo8(-31)
 1875 07ca D32E      		mov r13,r19
 1876 07cc 35EF      		ldi r19,lo8(-11)
 1877 07ce E32E      		mov r14,r19
 1878 07d0 35E0      		ldi r19,lo8(5)
 1879 07d2 F32E      		mov r15,r19
 1880 07d4 C78A      		std Z+23,r12
 1881 07d6 D08E      		std Z+24,r13
 1882 07d8 E18E      		std Z+25,r14
 1883 07da F28E      		std Z+26,r15
 665:main.c        ****   TX_NODE_TASK.offset.secs = 0;
 1885               	.LM221:
 1886 07dc 138E      		std Z+27,__zero_reg__
 1887 07de 148E      		std Z+28,__zero_reg__
 1888 07e0 158E      		std Z+29,__zero_reg__
 1889 07e2 168E      		std Z+30,__zero_reg__
 666:main.c        ****   TX_NODE_TASK.offset.nano_secs = 0;
 1891               	.LM222:
 1892 07e4 178E      		std Z+31,__zero_reg__
 1893 07e6 10A2      		std Z+32,__zero_reg__
 1894 07e8 11A2      		std Z+33,__zero_reg__
 1895 07ea 12A2      		std Z+34,__zero_reg__
 667:main.c        ****   nrk_activate_task(&TX_NODE_TASK);
 1897               	.LM223:
 1898 07ec C801      		movw r24,r16
 1899 07ee 0E94 0000 		call nrk_activate_task
 668:main.c        **** 
 669:main.c        ****   // PRIORITY 1 - LOWEST PRIORITY
 670:main.c        ****   TX_SERV_TASK.task = tx_serv_task;
 1901               	.LM224:
 1902 07f2 00E0      		ldi r16,lo8(TX_SERV_TASK)
 1903 07f4 10E0      		ldi r17,hi8(TX_SERV_TASK)
 1904 07f6 80E0      		ldi r24,lo8(gs(tx_serv_task))
 1905 07f8 90E0      		ldi r25,hi8(gs(tx_serv_task))
 1906 07fa F801      		movw r30,r16
 1907 07fc 9683      		std Z+6,r25
 1908 07fe 8583      		std Z+5,r24
 671:main.c        ****   nrk_task_set_stk(&TX_SERV_TASK, tx_serv_task_stack, NRK_APP_STACKSIZE);
 1910               	.LM225:
 1911 0800 40E0      		ldi r20,0
 1912 0802 52E0      		ldi r21,lo8(2)
 1913 0804 60E0      		ldi r22,lo8(tx_serv_task_stack)
 1914 0806 70E0      		ldi r23,hi8(tx_serv_task_stack)
 1915 0808 C801      		movw r24,r16
 1916 080a 0E94 0000 		call nrk_task_set_stk
 672:main.c        ****   TX_SERV_TASK.prio = 1;
 1918               	.LM226:
 1919 080e F801      		movw r30,r16
 1920 0810 C087      		std Z+8,r28
 673:main.c        ****   TX_SERV_TASK.FirstActivation = TRUE;
 1922               	.LM227:
 1923 0812 C783      		std Z+7,r28
 674:main.c        ****   TX_SERV_TASK.Type = BASIC_TASK;
 1925               	.LM228:
 1926 0814 C187      		std Z+9,r28
 675:main.c        ****   TX_SERV_TASK.SchType = PREEMPTIVE;
 1928               	.LM229:
 1929 0816 C287      		std Z+10,r28
 676:main.c        ****   TX_SERV_TASK.period.secs = 5;
 1931               	.LM230:
 1932 0818 8386      		std Z+11,r8
 1933 081a 9486      		std Z+12,r9
 1934 081c A586      		std Z+13,r10
 1935 081e B686      		std Z+14,r11
 677:main.c        ****   TX_SERV_TASK.period.nano_secs = 0;
 1937               	.LM231:
 1938 0820 1786      		std Z+15,__zero_reg__
 1939 0822 108A      		std Z+16,__zero_reg__
 1940 0824 118A      		std Z+17,__zero_reg__
 1941 0826 128A      		std Z+18,__zero_reg__
 678:main.c        ****   TX_SERV_TASK.cpu_reserve.secs = 0;
 1943               	.LM232:
 1944 0828 138A      		std Z+19,__zero_reg__
 1945 082a 148A      		std Z+20,__zero_reg__
 1946 082c 158A      		std Z+21,__zero_reg__
 1947 082e 168A      		std Z+22,__zero_reg__
 679:main.c        ****   TX_SERV_TASK.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 1949               	.LM233:
 1950 0830 C78A      		std Z+23,r12
 1951 0832 D08E      		std Z+24,r13
 1952 0834 E18E      		std Z+25,r14
 1953 0836 F28E      		std Z+26,r15
 680:main.c        ****   TX_SERV_TASK.offset.secs = 0;
 1955               	.LM234:
 1956 0838 138E      		std Z+27,__zero_reg__
 1957 083a 148E      		std Z+28,__zero_reg__
 1958 083c 158E      		std Z+29,__zero_reg__
 1959 083e 168E      		std Z+30,__zero_reg__
 681:main.c        ****   TX_SERV_TASK.offset.nano_secs = 0;
 1961               	.LM235:
 1962 0840 178E      		std Z+31,__zero_reg__
 1963 0842 10A2      		std Z+32,__zero_reg__
 1964 0844 11A2      		std Z+33,__zero_reg__
 1965 0846 12A2      		std Z+34,__zero_reg__
 682:main.c        ****   nrk_activate_task(&TX_SERV_TASK);
 1967               	.LM236:
 1968 0848 C801      		movw r24,r16
 1969 084a 0E94 0000 		call nrk_activate_task
 683:main.c        ****   
 684:main.c        ****   
 685:main.c        ****   nrk_kprintf(PSTR("Create done.\r\n"));
 1971               	.LM237:
 1972 084e 80E0      		ldi r24,lo8(__c.3920)
 1973 0850 90E0      		ldi r25,hi8(__c.3920)
 1974               	/* epilogue start */
 686:main.c        **** }
 1976               	.LM238:
 1977 0852 CF91      		pop r28
 1978 0854 1F91      		pop r17
 1979 0856 0F91      		pop r16
 1980 0858 FF90      		pop r15
 1981 085a EF90      		pop r14
 1982 085c DF90      		pop r13
 1983 085e CF90      		pop r12
 1984 0860 BF90      		pop r11
 1985 0862 AF90      		pop r10
 1986 0864 9F90      		pop r9
 1987 0866 8F90      		pop r8
 685:main.c        **** }
 1989               	.LM239:
 1990 0868 0C94 0000 		jmp nrk_kprintf
 1992               	.Lscope9:
 1994               		.stabd	78,0,0
 1995               		.section	.text.startup,"ax",@progbits
 1997               	.global	main
 1999               	main:
 2000               		.stabd	46,0,0
  89:main.c        ****   // setup ports/uart
 2002               	.LM240:
 2003               	.LFBB10:
 2004               	/* prologue: function */
 2005               	/* frame size = 0 */
 2006               	/* stack size = 0 */
 2007               	.L__stack_usage = 0
  91:main.c        ****   nrk_setup_uart (UART_BAUDRATE_115K2);
 2009               	.LM241:
 2010 0000 0E94 0000 		call nrk_setup_ports
  92:main.c        ****   nrk_init ();
 2012               	.LM242:
 2013 0004 80E1      		ldi r24,lo8(16)
 2014 0006 90E0      		ldi r25,0
 2015 0008 0E94 0000 		call nrk_setup_uart
  93:main.c        **** 
 2017               	.LM243:
 2018 000c 0E94 0000 		call nrk_init
  96:main.c        ****   nrk_led_clr(1);
 2020               	.LM244:
 2021 0010 80E0      		ldi r24,0
 2022 0012 90E0      		ldi r25,0
 2023 0014 0E94 0000 		call nrk_led_clr
  97:main.c        ****   nrk_led_clr(2);
 2025               	.LM245:
 2026 0018 81E0      		ldi r24,lo8(1)
 2027 001a 90E0      		ldi r25,0
 2028 001c 0E94 0000 		call nrk_led_clr
  98:main.c        ****   nrk_led_clr(3);
 2030               	.LM246:
 2031 0020 82E0      		ldi r24,lo8(2)
 2032 0022 90E0      		ldi r25,0
 2033 0024 0E94 0000 		call nrk_led_clr
  99:main.c        ****     
 2035               	.LM247:
 2036 0028 83E0      		ldi r24,lo8(3)
 2037 002a 90E0      		ldi r25,0
 2038 002c 0E94 0000 		call nrk_led_clr
 102:main.c        ****   blink_leds = 1;
 2040               	.LM248:
 2041 0030 81E0      		ldi r24,lo8(1)
 2042 0032 8093 0000 		sts print_incoming,r24
 103:main.c        **** 
 2044               	.LM249:
 2045 0036 8093 0000 		sts blink_leds,r24
 106:main.c        ****   cmd_tx_queue_mux  = nrk_sem_create(1, 6);
 2047               	.LM250:
 2048 003a 66E0      		ldi r22,lo8(6)
 2049 003c 0E94 0000 		call nrk_sem_create
 2050 0040 9093 0000 		sts net_tx_buf_mux+1,r25
 2051 0044 8093 0000 		sts net_tx_buf_mux,r24
 107:main.c        ****   node_tx_queue_mux = nrk_sem_create(1, 6);
 2053               	.LM251:
 2054 0048 66E0      		ldi r22,lo8(6)
 2055 004a 81E0      		ldi r24,lo8(1)
 2056 004c 0E94 0000 		call nrk_sem_create
 2057 0050 9093 0000 		sts cmd_tx_queue_mux+1,r25
 2058 0054 8093 0000 		sts cmd_tx_queue_mux,r24
 108:main.c        ****   serv_tx_queue_mux = nrk_sem_create(1, 6);
 2060               	.LM252:
 2061 0058 66E0      		ldi r22,lo8(6)
 2062 005a 81E0      		ldi r24,lo8(1)
 2063 005c 0E94 0000 		call nrk_sem_create
 2064 0060 9093 0000 		sts node_tx_queue_mux+1,r25
 2065 0064 8093 0000 		sts node_tx_queue_mux,r24
 109:main.c        ****   hand_rx_queue_mux = nrk_sem_create(1, 6);
 2067               	.LM253:
 2068 0068 66E0      		ldi r22,lo8(6)
 2069 006a 81E0      		ldi r24,lo8(1)
 2070 006c 0E94 0000 		call nrk_sem_create
 2071 0070 9093 0000 		sts serv_tx_queue_mux+1,r25
 2072 0074 8093 0000 		sts serv_tx_queue_mux,r24
 110:main.c        **** 
 2074               	.LM254:
 2075 0078 66E0      		ldi r22,lo8(6)
 2076 007a 81E0      		ldi r24,lo8(1)
 2077 007c 0E94 0000 		call nrk_sem_create
 2078 0080 9093 0000 		sts hand_rx_queue_mux+1,r25
 2079 0084 8093 0000 		sts hand_rx_queue_mux,r24
 113:main.c        ****   packet_queue_init(&node_tx_queue);
 2081               	.LM255:
 2082 0088 80E0      		ldi r24,lo8(cmd_tx_queue)
 2083 008a 90E0      		ldi r25,hi8(cmd_tx_queue)
 2084 008c 0E94 0000 		call packet_queue_init
 114:main.c        ****   packet_queue_init(&serv_tx_queue);
 2086               	.LM256:
 2087 0090 80E0      		ldi r24,lo8(node_tx_queue)
 2088 0092 90E0      		ldi r25,hi8(node_tx_queue)
 2089 0094 0E94 0000 		call packet_queue_init
 115:main.c        ****   packet_queue_init(&hand_rx_queue);
 2091               	.LM257:
 2092 0098 80E0      		ldi r24,lo8(serv_tx_queue)
 2093 009a 90E0      		ldi r25,hi8(serv_tx_queue)
 2094 009c 0E94 0000 		call packet_queue_init
 116:main.c        **** 
 2096               	.LM258:
 2097 00a0 80E0      		ldi r24,lo8(hand_rx_queue)
 2098 00a2 90E0      		ldi r25,hi8(hand_rx_queue)
 2099 00a4 0E94 0000 		call packet_queue_init
 118:main.c        ****   bmac_task_config();
 2101               	.LM259:
 2102 00a8 20E0      		ldi r18,0
 2103 00aa 30E0      		ldi r19,0
 2104 00ac A901      		movw r20,r18
 2105 00ae 60E0      		ldi r22,0
 2106 00b0 70E0      		ldi r23,0
 2107 00b2 CB01      		movw r24,r22
 2108 00b4 0E94 0000 		call nrk_time_set
 119:main.c        ****   nrk_create_taskset();
 2110               	.LM260:
 2111 00b8 0E94 0000 		call bmac_task_config
 120:main.c        ****   bmac_init (13);
 2113               	.LM261:
 2114 00bc 0E94 0000 		call nrk_create_taskset
 121:main.c        ****   nrk_start ();
 2116               	.LM262:
 2117 00c0 8DE0      		ldi r24,lo8(13)
 2118 00c2 0E94 0000 		call bmac_init
 122:main.c        ****   return 0;
 2120               	.LM263:
 2121 00c6 0E94 0000 		call nrk_start
 124:main.c        **** 
 2123               	.LM264:
 2124 00ca 80E0      		ldi r24,0
 2125 00cc 90E0      		ldi r25,0
 2126 00ce 0895      		ret
 2128               	.Lscope10:
 2130               		.stabd	78,0,0
 2131               		.section	.progmem.data,"a",@progbits
 2134               	__c.3920:
 2135 0000 4372 6561 		.string	"Create done.\r\n"
 2135      7465 2064 
 2135      6F6E 652E 
 2135      0D0A 00
 2138               	__c.3911:
 2139 000f 5345 5256 		.string	"SERV LED OFF\r\n"
 2139      204C 4544 
 2139      204F 4646 
 2139      0D0A 00
 2142               	__c.3909:
 2143 001e 5345 5256 		.string	"SERV LED ON\r\n"
 2143      204C 4544 
 2143      204F 4E0D 
 2143      0A00 
 2146               	__c.3898:
 2147 002c 5458 2064 		.string	"TX done signal error\r\n"
 2147      6F6E 6520 
 2147      7369 676E 
 2147      616C 2065 
 2147      7272 6F72 
 2150               	__c.3880:
 2151 0043 5458 2064 		.string	"TX done signal error\r\n"
 2151      6F6E 6520 
 2151      7369 676E 
 2151      616C 2065 
 2151      7272 6F72 
 2154               	__c.3878:
 2155 005a 6173 6D20 		.string	"asm pkt:\r\n"
 2155      706B 743A 
 2155      0D0A 00
 2158               	__c.3841:
 2159 0065 7278 3A0D 		.string	"rx:\r\n"
 2159      0A00 
 2162               	__c.3839:
 2163 006b 706B 7420 		.string	"pkt ready:\r\n"
 2163      7265 6164 
 2163      793A 0D0A 
 2163      00
 2166               	__c.3809:
 2167 0078 0A00      		.string	"\n"
 2168               		.comm	blink_leds,1,1
 2169               		.comm	print_incoming,1,1
 2170               	.global	seq_num
 2171               		.section .bss
 2174               	seq_num:
 2175 0000 0000      		.zero	2
 2176               		.comm	server_seq_num,2,1
 2177               		.comm	seq_pool,10,1
 2178               		.comm	hand_rx_queue_mux,2,1
 2179               		.comm	hand_rx_queue,139,1
 2180               		.comm	serv_tx_queue_mux,2,1
 2181               		.comm	serv_tx_queue,139,1
 2182               		.comm	node_tx_queue_mux,2,1
 2183               		.comm	node_tx_queue,139,1
 2184               		.comm	cmd_tx_queue_mux,2,1
 2185               		.comm	cmd_tx_queue,139,1
 2186               		.comm	serv_tx_buf,116,1
 2187               		.comm	net_tx_buf_mux,2,1
 2188               	.global	net_tx_index
 2191               	net_tx_index:
 2192 0002 00        		.zero	1
 2193               		.comm	net_tx_buf,116,1
 2194               	.global	serv_rx_index
 2197               	serv_rx_index:
 2198 0003 00        		.zero	1
 2199               		.comm	serv_rx_buf,116,1
 2200               		.comm	net_rx_buf,116,1
 2201               		.comm	tx_serv_task_stack,512,1
 2202               		.comm	tx_node_task_stack,512,1
 2203               		.comm	tx_cmd_task_stack,512,1
 2204               		.comm	rx_serv_task_stack,512,1
 2205               		.comm	rx_node_task_stack,512,1
 2206               		.comm	TX_SERV_TASK,35,1
 2207               		.comm	TX_NODE_TASK,35,1
 2208               		.comm	TX_CMD_TASK,35,1
 2209               		.comm	RX_SERV_TASK,35,1
 2210               		.comm	RX_NODE_TASK,35,1
 2211               		.comm	error_num,1,1
 2212               		.comm	error_task,1,1
 2213               		.comm	bmac_rfTxInfo,7,1
 2214               		.comm	bmac_rfRxInfo,12,1
 2215               		.comm	bmac_enable_signal,1,1
 2216               		.comm	bmac_tx_pkt_done_signal,1,1
 2217               		.comm	bmac_rx_pkt_signal,1,1
 2218               		.comm	nrk_kernel_stk_ptr,2,1
 2219               		.comm	nrk_idle_task_stk,512,1
 2220               		.comm	_nrk_signal_list,4,1
 2261               		.text
 2263               	.Letext0:
 2264               		.ident	"GCC: (GNU) 4.9.1"
 2265               	.global __do_copy_data
 2266               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:4      *ABS*:000000000000003f __SREG__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:354    .text:0000000000000000 rx_node_task
                            *COM*:0000000000000074 net_rx_buf
                            *COM*:0000000000000001 blink_leds
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2162   .progmem.data:000000000000006b __c.3839
                            *COM*:0000000000000001 print_incoming
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2158   .progmem.data:0000000000000065 __c.3841
                            *COM*:000000000000000a seq_pool
                            *COM*:0000000000000002 serv_tx_queue_mux
                            *COM*:000000000000008b serv_tx_queue
                            *COM*:0000000000000002 hand_rx_queue_mux
                            *COM*:000000000000008b hand_rx_queue
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:588    .text:0000000000000146 tx_cmd_task
                            *COM*:0000000000000002 cmd_tx_queue_mux
                            *COM*:000000000000008b cmd_tx_queue
                            *COM*:0000000000000002 net_tx_buf_mux
                            *COM*:0000000000000074 net_tx_buf
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2191   .bss:0000000000000002 net_tx_index
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2154   .progmem.data:000000000000005a __c.3878
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2150   .progmem.data:0000000000000043 __c.3880
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:820    .text:0000000000000286 tx_node_task
                            *COM*:0000000000000002 node_tx_queue_mux
                            *COM*:000000000000008b node_tx_queue
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2146   .progmem.data:000000000000002c __c.3898
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:1053   .text:00000000000003c0 tx_serv_task
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2142   .progmem.data:000000000000001e __c.3909
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2138   .progmem.data:000000000000000f __c.3911
                            *COM*:0000000000000074 serv_tx_buf
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:1202   .text:000000000000047c clear_serv_buf
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2197   .bss:0000000000000003 serv_rx_index
                            *COM*:0000000000000074 serv_rx_buf
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:1242   .text:0000000000000498 get_server_input
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2166   .progmem.data:0000000000000078 __c.3809
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:1374   .text:0000000000000536 rx_serv_task
                            *COM*:0000000000000002 server_seq_num
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:1525   .text:000000000000060a clear_tx_buf
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:1565   .text:0000000000000626 nrk_create_taskset
                            *COM*:0000000000000023 RX_NODE_TASK
                            *COM*:0000000000000200 rx_node_task_stack
                            *COM*:0000000000000023 RX_SERV_TASK
                            *COM*:0000000000000023 TX_CMD_TASK
                            *COM*:0000000000000200 tx_cmd_task_stack
                            *COM*:0000000000000023 TX_NODE_TASK
                            *COM*:0000000000000200 tx_node_task_stack
                            *COM*:0000000000000023 TX_SERV_TASK
                            *COM*:0000000000000200 tx_serv_task_stack
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2134   .progmem.data:0000000000000000 __c.3920
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:1999   .text.startup:0000000000000000 main
/var/folders/57/dy66zcf543x9s42pt1yfw30r0000gn/T//ccHLfFXo.s:2174   .bss:0000000000000000 seq_num
                            *COM*:0000000000000200 rx_serv_task_stack
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000007 bmac_rfTxInfo
                            *COM*:000000000000000c bmac_rfRxInfo
                            *COM*:0000000000000001 bmac_enable_signal
                            *COM*:0000000000000001 bmac_tx_pkt_done_signal
                            *COM*:0000000000000001 bmac_rx_pkt_signal
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000200 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
bmac_rx_pkt_set_buffer
bmac_started
nrk_wait_until_next_period
nrk_led_set
nrk_led_clr
bmac_rx_pkt_ready
nrk_kprintf
parse_msg
bmac_rx_pkt_get
print_packet
bmac_rx_pkt_release
in_sequence_pool
add_to_sequence_pool
get_sequence_number
update_sequence_pool
nrk_sem_pend
push
nrk_sem_post
bmac_get_tx_done_signal
nrk_signal_register
pop
assemble_packet
bmac_tx_pkt_nonblocking
nrk_event_wait
assemble_serv_packet
printf
nrk_uart_data_ready
__iob
fgetc
putchar
nrk_uart_rx_signal_get
parse_serv_msg
nrk_task_set_stk
nrk_activate_task
nrk_setup_ports
nrk_setup_uart
nrk_init
nrk_sem_create
packet_queue_init
nrk_time_set
bmac_task_config
bmac_init
nrk_start
__do_copy_data
__do_clear_bss
